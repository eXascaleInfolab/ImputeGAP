<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <link rel="shortcut icon" href="https://www.naterscreations.com/imputegap/favicon.png"/><!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>imputegap.recovery.imputation - ImputeGAP 1.1.1</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">ImputeGAP 1.1.1</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="https://www.naterscreations.com/imputegap/logo_imputegab.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">ImputeGAP 1.1.1</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div style="margin-top:10px; display: flex; gap: 10px; align-items: center; padding: 5px; margin-left:15px;">
    <a href="https://github.com/eXascaleInfolab/ImputeGAP" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-original-title="GitHub">
        <svg class="svg-inline--fa fa-github fa-lg" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" data-fa-i2svg="" width="25px">
            <path fill="#63AEFF" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg><!-- <i class="fa-brands fa-github fa-lg" aria-hidden="true"></i> Font Awesome fontawesome.com -->
    </a>

    <a href="https://pypi.org/project/imputegap/" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-original-title="PyPI">
    <svg class="svg-inline--fa fa-box fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="box" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg="" width="22px" >
        <path fill="#63AEFF" d="M50.7 58.5L0 160H208V32H93.7C75.5 32 58.9 42.3 50.7 58.5zM240 160H448L397.3 58.5C389.1 42.3 372.5 32 354.3 32H240V160zm208 32H0V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V192z"></path></svg><!-- <i class="fa-solid fa-box fa-lg" aria-hidden="true"></i> Font Awesome fontawesome.com -->
    </a>

    <!--<a href="mailto:contact@example.com" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-original-title="Contact Us">
        <svg class="svg-inline--fa fa-envelope fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="22px">
            <path fill="#63AEFF" d="M502.3 190.8 327.4 338.6c-21.4 17.9-53.4 17.9-74.8 0L9.7 190.8C3.9 186.4 0 179.8 0 172.6V112c0-26.5 21.5-48 48-48h416c26.5 0 48 21.5 48 48v60.6c0 7.2-3.9 13.8-9.7 18.2zM0 208v192c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48V208l-165.9 138.2c-37.5 31.3-91.7 31.3-129.2 0L0 208z"></path>
        </svg>
    </a>-->
</div><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../datasets.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../missingness_patterns.html">Missingness Patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks.html">Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../about_us.html">About Us</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../imputegap.html">API</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../imputegap.manager.html">imputegap.recovery.manager package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../imputegap.imputation.html">imputegap.recovery.imputation package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../imputegap.optimization.html">imputegap.recovery.optimization package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../imputegap.benchmark.html">imputegap.recovery.benchmark package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../imputegap.explainer.html">imputegap.recovery.explainer package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../imputegap.downstream.html">imputegap.recovery.downstream package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../imputegap.evaluation.html">imputegap.recovery.evaluation package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../imputegap.utils.html">imputegap.tools.utils package</a></li>
</ul>
</li>
</ul>

</div><div class="sidebar-scroll"></div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for imputegap.recovery.imputation</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.recovery.downstream</span><span class="w"> </span><span class="kn">import</span> <span class="n">Downstream</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.recovery.evaluation</span><span class="w"> </span><span class="kn">import</span> <span class="n">Evaluation</span>

<span class="n">is_optimized</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cdrec&quot;</span><span class="p">,</span> <span class="s2">&quot;stmvl&quot;</span><span class="p">,</span> <span class="s2">&quot;iim&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="BaseImputer">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.BaseImputer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseImputer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for imputation algorithms.</span>

<span class="sd">    This class provides common methods for imputation tasks such as scoring, parameter checking,</span>
<span class="sd">    and optimization. Specific algorithms should inherit from this class and implement the `impute` method.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    impute(params=None):</span>
<span class="sd">        Abstract method to perform the imputation.</span>
<span class="sd">    score(input_data, recov_data=None, downstream=None):</span>
<span class="sd">        Compute metrics for the imputed time series.</span>
<span class="sd">    _check_params(user_def, params):</span>
<span class="sd">        Check and format parameters for imputation.</span>
<span class="sd">    _optimize(parameters={}):</span>
<span class="sd">        Optimize hyperparameters for the imputation algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">logs</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BaseImputer.__init__">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.BaseImputer.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">incomp_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the BaseImputer with an infected time series matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        incomp_data : numpy.ndarray</span>
<span class="sd">            Matrix used during the imputation of the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span> <span class="o">=</span> <span class="n">incomp_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">downstream_metrics</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">downstream_plot</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="BaseImputer.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.BaseImputer.impute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method to perform the imputation. Must be implemented in subclasses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dict, optional</span>
<span class="sd">            Dictionary of algorithm parameters (default is None).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the method is not implemented by a subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method should be overridden by subclasses&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseImputer.score">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.BaseImputer.score">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">recov_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downstream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">security</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute evaluation metrics for the imputed time series.</span>
<span class="sd">        Upstream and downstream metrics can be computed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_data : numpy.ndarray</span>
<span class="sd">            The original time series without contamination.</span>

<span class="sd">        recov_data : numpy.ndarray, optional</span>
<span class="sd">            The imputed time series (default is None).</span>

<span class="sd">        downstream : dict, optional</span>
<span class="sd">            Dictionary that calls, if active, the downstream evaluation. (default is None).</span>
<span class="sd">            format : {&quot;model&quot;: &quot;forcaster&quot;, &quot;params&quot;: parameters}</span>

<span class="sd">        mask: numpy.ndarray, optional</span>
<span class="sd">            Mask describing the missing values (default is None).</span>
<span class="sd">            If None, take the missing values in the ts_m matrix (contaminated matrix).</span>

<span class="sd">        security: bool, optional</span>
<span class="sd">            Check if the no imputed values are the same in the imputed matrix and the raw data</span>

<span class="sd">        verbose : bool, optional</span>
<span class="sd">            Display the message from the evaluator (default is True).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">            &gt;&gt;&gt; imputer.score(ts.data, imputer.recov_data) # upstream</span>
<span class="sd">            &gt;&gt;&gt; imputer.score(ts.data, imputer.recov_data, {&quot;task&quot;: &quot;forecast&quot;, &quot;model&quot;: &quot;hw-add&quot;, &quot;comparator&quot;: &quot;ZeroImputation&quot;}) # downstream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">recov_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">recov_data</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">downstream</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">downstream</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">downstream_metrics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">downstream_plot</span> <span class="o">=</span> <span class="n">Downstream</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">downstream</span><span class="p">)</span><span class="o">.</span><span class="n">downstream_analysis</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">Evaluation</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">security</span><span class="o">=</span><span class="n">security</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span><span class="o">.</span><span class="n">compute_all_metrics</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_check_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Format the parameters for optimization or imputation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        user_def : bool</span>
<span class="sd">            Whether the parameters are user-defined or not.</span>
<span class="sd">        params : dict or list</span>
<span class="sd">            List or dictionary of parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            Formatted parameters as a tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">user_def</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">params</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s2">&quot;iim&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">learning_neighbours</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">algo_code</span> <span class="o">=</span> <span class="s2">&quot;iim &quot;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\W_]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">learning_neighbours</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">learning_neighbours</span><span class="p">,</span> <span class="n">algo_code</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s2">&quot;mrnn&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">hidden_dim</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sequence_length</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;mrnn&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conduct the optimization of the hyperparameters using different optimizers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters : dict</span>
<span class="sd">            Dictionary containing optimization configurations such as input_data, optimizer, and options.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.recovery.optimization</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optimization</span>

        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;optimizer&#39;</span><span class="p">,</span> <span class="s2">&quot;ray_tune&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">is_optimized</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">optimizer</span> <span class="o">!=</span> <span class="s2">&quot;ray_tune&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">This algorithm &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="si">}</span><span class="s2">&#39; is not optimized for this optimizer. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">Please use `ray_tune` to optimize the hyperparameters for:</span><span class="se">\n\t\t</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">is_optimized</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">Please use update your call :</span><span class="se">\n\t\t</span><span class="s2">.impute(user_def=False, params={&#39;input_data&#39;: ts.data, &#39;optimizer&#39;: &#39;ray_tune&#39;})&quot;</span>
            <span class="p">)</span>

        <span class="n">input_data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;input_data&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;input_data&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ts_input&#39;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">input_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Need input_data to be able to adapt the hyper-parameters: </span><span class="si">{</span><span class="n">input_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">optimizer</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(OPTI) optimizer&quot;</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="s2">&quot;has been called with&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="s2">&quot;...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bayesian&quot;</span><span class="p">,</span> <span class="s2">&quot;bo&quot;</span><span class="p">,</span> <span class="s2">&quot;bayesopt&quot;</span><span class="p">]:</span>
            <span class="n">n_calls_d</span><span class="p">,</span> <span class="n">n_random_starts_d</span><span class="p">,</span> <span class="n">acq_func_d</span><span class="p">,</span> <span class="n">selected_metrics_d</span> <span class="o">=</span> <span class="n">defaults</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="p">{})</span>

            <span class="n">n_calls</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_calls&#39;</span><span class="p">,</span> <span class="n">n_calls_d</span><span class="p">)</span>
            <span class="n">random_starts</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_random_starts&#39;</span><span class="p">,</span> <span class="n">n_random_starts_d</span><span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;acq_func&#39;</span><span class="p">,</span> <span class="n">acq_func_d</span><span class="p">)</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metrics&#39;</span><span class="p">,</span> <span class="n">selected_metrics_d</span><span class="p">)</span>

            <span class="n">bo_optimizer</span> <span class="o">=</span> <span class="n">Optimization</span><span class="o">.</span><span class="n">Bayesian</span><span class="p">()</span>

            <span class="n">optimal_params</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bo_optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">input_data</span><span class="o">=</span><span class="n">input_data</span><span class="p">,</span>
                                                      <span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span>
                                                      <span class="n">metrics</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span>
                                                      <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span>
                                                      <span class="n">n_calls</span><span class="o">=</span><span class="n">n_calls</span><span class="p">,</span>
                                                      <span class="n">n_random_starts</span><span class="o">=</span><span class="n">random_starts</span><span class="p">,</span>
                                                      <span class="n">acq_func</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">optimal_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(OPTI) optimization does not find results for &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="s2">&quot; &gt; load default params.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">optimal_params</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pso&quot;</span><span class="p">,</span> <span class="s2">&quot;particle_swarm&quot;</span><span class="p">]:</span>
            <span class="n">n_particles_d</span><span class="p">,</span> <span class="n">c1_d</span><span class="p">,</span> <span class="n">c2_d</span><span class="p">,</span> <span class="n">w_d</span><span class="p">,</span> <span class="n">iterations_d</span><span class="p">,</span> <span class="n">n_processes_d</span><span class="p">,</span> <span class="n">selected_metrics_d</span> <span class="o">=</span> <span class="n">defaults</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="p">{})</span>

            <span class="n">n_particles</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_particles&#39;</span><span class="p">,</span> <span class="n">n_particles_d</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;c1&#39;</span><span class="p">,</span> <span class="n">c1_d</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;c2&#39;</span><span class="p">,</span> <span class="n">c2_d</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">w_d</span><span class="p">)</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;iterations&#39;</span><span class="p">,</span> <span class="n">iterations_d</span><span class="p">)</span>
            <span class="n">n_processes</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_processes&#39;</span><span class="p">,</span> <span class="n">n_processes_d</span><span class="p">)</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metrics&#39;</span><span class="p">,</span> <span class="n">selected_metrics_d</span><span class="p">)</span>

            <span class="n">swarm_optimizer</span> <span class="o">=</span> <span class="n">Optimization</span><span class="o">.</span><span class="n">ParticleSwarm</span><span class="p">()</span>

            <span class="n">optimal_params</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">swarm_optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">input_data</span><span class="o">=</span><span class="n">input_data</span><span class="p">,</span>
                                                         <span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span>
                                                         <span class="n">metrics</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span>
                                                         <span class="n">n_particles</span><span class="o">=</span><span class="n">n_particles</span><span class="p">,</span> <span class="n">c1</span><span class="o">=</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span><span class="n">c2</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                                                         <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="n">n_processes</span><span class="o">=</span><span class="n">n_processes</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sh&quot;</span><span class="p">,</span> <span class="s2">&quot;successive_halving&quot;</span><span class="p">]:</span>
            <span class="n">num_configs_d</span><span class="p">,</span> <span class="n">num_iterations_d</span><span class="p">,</span> <span class="n">reduction_factor_d</span><span class="p">,</span> <span class="n">selected_metrics_d</span> <span class="o">=</span> <span class="n">defaults</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="p">{})</span>

            <span class="n">num_configs</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_configs&#39;</span><span class="p">,</span> <span class="n">num_configs_d</span><span class="p">)</span>
            <span class="n">num_iterations</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_iterations&#39;</span><span class="p">,</span> <span class="n">num_iterations_d</span><span class="p">)</span>
            <span class="n">reduction_factor</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reduction_factor&#39;</span><span class="p">,</span> <span class="n">reduction_factor_d</span><span class="p">)</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metrics&#39;</span><span class="p">,</span> <span class="n">selected_metrics_d</span><span class="p">)</span>

            <span class="n">sh_optimizer</span> <span class="o">=</span> <span class="n">Optimization</span><span class="o">.</span><span class="n">SuccessiveHalving</span><span class="p">()</span>

            <span class="n">optimal_params</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sh_optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">input_data</span><span class="o">=</span><span class="n">input_data</span><span class="p">,</span>
                                                      <span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span>
                                                      <span class="n">metrics</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span>
                                                      <span class="n">num_configs</span><span class="o">=</span><span class="n">num_configs</span><span class="p">,</span> <span class="n">num_iterations</span><span class="o">=</span><span class="n">num_iterations</span><span class="p">,</span>
                                                      <span class="n">reduction_factor</span><span class="o">=</span><span class="n">reduction_factor</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ray_tune&quot;</span><span class="p">,</span> <span class="s2">&quot;ray&quot;</span><span class="p">]:</span>
            <span class="n">selected_metrics_d</span><span class="p">,</span> <span class="n">n_calls_d</span><span class="p">,</span> <span class="n">max_concurrent_trials_d</span> <span class="o">=</span> <span class="n">defaults</span>

            <span class="n">options</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">n_calls</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_calls&#39;</span><span class="p">,</span> <span class="n">n_calls_d</span><span class="p">)</span>
            <span class="n">max_concurrent_trials</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_concurrent_trials&#39;</span><span class="p">,</span> <span class="n">max_concurrent_trials_d</span><span class="p">)</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metrics&#39;</span><span class="p">,</span> <span class="n">selected_metrics_d</span><span class="p">)</span>

            <span class="n">ray_tune_optimizer</span> <span class="o">=</span> <span class="n">Optimization</span><span class="o">.</span><span class="n">RayTune</span><span class="p">()</span>
            <span class="n">optimal_params</span> <span class="o">=</span> <span class="n">ray_tune_optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">input_data</span><span class="o">=</span><span class="n">input_data</span><span class="p">,</span> <span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">n_calls</span><span class="o">=</span><span class="n">n_calls</span><span class="p">,</span> <span class="n">max_concurrent_trials</span><span class="o">=</span><span class="n">max_concurrent_trials</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_calls_d</span><span class="p">,</span> <span class="n">selected_metrics_d</span> <span class="o">=</span> <span class="n">defaults</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="p">{})</span>

            <span class="n">n_calls</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n_calls&#39;</span><span class="p">,</span> <span class="n">n_calls_d</span><span class="p">)</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;metrics&#39;</span><span class="p">,</span> <span class="n">selected_metrics_d</span><span class="p">)</span>

            <span class="n">go_optimizer</span> <span class="o">=</span> <span class="n">Optimization</span><span class="o">.</span><span class="n">Greedy</span><span class="p">()</span>

            <span class="n">optimal_params</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">go_optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">input_data</span><span class="o">=</span><span class="n">input_data</span><span class="p">,</span>
                                                      <span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span>
                                                      <span class="n">metrics</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span>
                                                      <span class="n">n_calls</span><span class="o">=</span><span class="n">n_calls</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">optimal_params</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_dl_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_ratio</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the proportion of missing values in the contaminated data is acceptable</span>
<span class="sd">        for training a deep learning model. If more than 40% of the values are missing,</span>
<span class="sd">        the function returns False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the missing data ratio is less than or equal to 40%, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">missing_ratio</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_missing_ratio</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">)</span>

        <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">split_ratio</span>

        <span class="k">if</span> <span class="n">missing_ratio</span> <span class="o">&lt;=</span> <span class="n">ratio</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(IMP) The proportion of missing values </span><span class="si">{</span><span class="n">missing_ratio</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% is too high to train an effective deep learning model, limited to </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span><span class="si">}</span><span class="s2">%.</span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="s2">&quot;Please consider reducing the contamination rate or selecting a different family of imputation methods&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="Imputation">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Imputation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class containing static methods for evaluating and running imputation algorithms on time series data.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    evaluate_params(input_data, incomp_data, configuration, algorithm=&quot;cdrec&quot;):</span>
<span class="sd">        Evaluate imputation performance using given parameters and algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Imputation.evaluate_params">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.evaluate_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_params</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">incomp_data</span><span class="p">,</span> <span class="n">configuration</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;cdrec&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate various metrics for given parameters and imputation algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_data : numpy.ndarray</span>
<span class="sd">            The original time series without contamination.</span>
<span class="sd">        incomp_data : numpy.ndarray</span>
<span class="sd">            The time series with contamination.</span>
<span class="sd">        configuration : tuple</span>
<span class="sd">            Tuple of the configuration of the algorithm.</span>
<span class="sd">        algorithm : str, optional</span>
<span class="sd">            Imputation algorithm to use. Valid values: &#39;cdrec&#39;, &#39;mrnn&#39;, &#39;stmvl&#39;, &#39;iim&#39; (default is &#39;cdrec&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary of computed evaluation metrics.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">configuration</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">configuration</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;cdrec&#39;</span><span class="p">:</span>
            <span class="n">rank</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="n">configuration</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="n">Imputation</span><span class="o">.</span><span class="n">MatrixCompletion</span><span class="o">.</span><span class="n">CDRec</span><span class="p">(</span><span class="n">incomp_data</span><span class="p">)</span>
            <span class="n">algo</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">algo</span><span class="o">.</span><span class="n">impute</span><span class="p">(</span><span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;rank&quot;</span><span class="p">:</span> <span class="n">rank</span><span class="p">,</span> <span class="s2">&quot;epsilon&quot;</span><span class="p">:</span> <span class="n">epsilon</span><span class="p">,</span> <span class="s2">&quot;iterations&quot;</span><span class="p">:</span> <span class="n">iterations</span><span class="p">})</span>

        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;iim&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">configuration</span><span class="p">]</span>
            <span class="n">learning_neighbours</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">alg_code</span> <span class="o">=</span> <span class="s2">&quot;iim &quot;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\W_]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">learning_neighbours</span><span class="p">))</span>

            <span class="n">algo</span> <span class="o">=</span> <span class="n">Imputation</span><span class="o">.</span><span class="n">MachineLearning</span><span class="o">.</span><span class="n">IIM</span><span class="p">(</span><span class="n">incomp_data</span><span class="p">)</span>
            <span class="n">algo</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">algo</span><span class="o">.</span><span class="n">impute</span><span class="p">(</span><span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;learning_neighbours&quot;</span><span class="p">:</span> <span class="n">learning_neighbours</span><span class="p">,</span> <span class="s2">&quot;alg_code&quot;</span><span class="p">:</span> <span class="n">alg_code</span><span class="p">})</span>

        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;mrnn&#39;</span><span class="p">:</span>
            <span class="n">hidden_dim</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="n">configuration</span>

            <span class="n">algo</span> <span class="o">=</span> <span class="n">Imputation</span><span class="o">.</span><span class="n">DeepLearning</span><span class="o">.</span><span class="n">MRNN</span><span class="p">(</span><span class="n">incomp_data</span><span class="p">)</span>
            <span class="n">algo</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">algo</span><span class="o">.</span><span class="n">impute</span><span class="p">(</span><span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;hidden_dim&quot;</span><span class="p">:</span> <span class="n">hidden_dim</span><span class="p">,</span> <span class="s2">&quot;learning_rate&quot;</span><span class="p">:</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="s2">&quot;iterations&quot;</span><span class="p">:</span> <span class="n">iterations</span><span class="p">,</span>
                                <span class="s2">&quot;seq_length&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">})</span>

        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;stmvl&#39;</span><span class="p">:</span>
            <span class="n">window_size</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">configuration</span>

            <span class="n">algo</span> <span class="o">=</span> <span class="n">Imputation</span><span class="o">.</span><span class="n">PatternSearch</span><span class="o">.</span><span class="n">STMVL</span><span class="p">(</span><span class="n">incomp_data</span><span class="p">)</span>
            <span class="n">algo</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">algo</span><span class="o">.</span><span class="n">impute</span><span class="p">(</span><span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;window_size&quot;</span><span class="p">:</span> <span class="n">window_size</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="n">alpha</span><span class="p">})</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid algorithm: </span><span class="si">{</span><span class="n">algorithm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">algo</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
        <span class="n">error_measures</span> <span class="o">=</span> <span class="n">algo</span><span class="o">.</span><span class="n">metrics</span>

        <span class="k">return</span> <span class="n">error_measures</span></div>


<div class="viewcode-block" id="Imputation.Statistics">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">Statistics</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class containing specific imputation algorithms for statistical methods.</span>

<span class="sd">        Subclasses</span>
<span class="sd">        ----------</span>
<span class="sd">        ZeroImpute :</span>
<span class="sd">            Imputation method that replaces missing values with zeros.</span>
<span class="sd">        MinImpute :</span>
<span class="sd">            Imputation method that replaces missing values with the minimum value of the ground truth.</span>
<span class="sd">        MeanImputeBySeries :</span>
<span class="sd">            Imputation method that replaces missing values with the minimum value of the ground truth by series.</span>
<span class="sd">        Interpolation :</span>
<span class="sd">            Imputation method that replaces missing values with the Interpolation</span>
<span class="sd">        KNNImpute :</span>
<span class="sd">            Imputation method that replaces missing values with KNNImpute logic</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Imputation.Statistics.ZeroImpute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.ZeroImpute">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">ZeroImpute</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            ZeroImpute class to impute missing values with zeros.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, params=None):</span>
<span class="sd">                Perform imputation by replacing missing values with zeros.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;zero_impute&quot;</span>

<div class="viewcode-block" id="Imputation.Statistics.ZeroImpute.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.ZeroImpute.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Impute missing values by replacing them with zeros.</span>
<span class="sd">                Template for adding external new algorithm</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Dictionary of algorithm parameters (default is None).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : ZeroImpute</span>
<span class="sd">                    The object with `recov_data` set.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.zero_impute</span><span class="w"> </span><span class="kn">import</span> <span class="n">zero_impute</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">zero_impute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.Statistics.MeanImpute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.MeanImpute">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">MeanImpute</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MeanImpute class to impute missing values with the mean value of the ground truth.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, params=None):</span>
<span class="sd">                Perform imputation by replacing missing values with the mean value of the ground truth.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;mean_impute&quot;</span>

<div class="viewcode-block" id="Imputation.Statistics.MeanImpute.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.MeanImpute.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Impute missing values by replacing them with the mean value of the ground truth.</span>
<span class="sd">                Template for adding external new algorithm</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Dictionary of algorithm parameters (default is None).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : MinImpute</span>
<span class="sd">                    The object with `recov_data` set.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.mean_impute</span><span class="w"> </span><span class="kn">import</span> <span class="n">mean_impute</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">mean_impute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.Statistics.MinImpute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.MinImpute">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">MinImpute</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MinImpute class to impute missing values with the minimum value of the ground truth.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, params=None):</span>
<span class="sd">                Perform imputation by replacing missing values with the minimum value of the ground truth.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;min_impute&quot;</span>

<div class="viewcode-block" id="Imputation.Statistics.MinImpute.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.MinImpute.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Impute missing values by replacing them with the minimum value of the ground truth.</span>
<span class="sd">                Template for adding external new algorithm</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Dictionary of algorithm parameters (default is None).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : MinImpute</span>
<span class="sd">                    The object with `recov_data` set.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.min_impute</span><span class="w"> </span><span class="kn">import</span> <span class="n">min_impute</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">min_impute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.Statistics.MeanImputeBySeries">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.MeanImputeBySeries">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">MeanImputeBySeries</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MeanImputeBySeries class to impute missing values with the mean value by series.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, params=None):</span>
<span class="sd">                Perform imputation by replacing missing values with the mean value by series</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;mean_impute&quot;</span>

<div class="viewcode-block" id="Imputation.Statistics.MeanImputeBySeries.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.MeanImputeBySeries.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Impute missing values by replacing them with the mean value of the series.</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : MeanImputeBySeries</span>
<span class="sd">                    The object with `recov_data` set.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.mean_impute_by_series</span><span class="w"> </span><span class="kn">import</span> <span class="n">mean_impute_by_series</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">mean_impute_by_series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.Statistics.Test">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.Test">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">Test</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            ZeroImpute class to impute missing values with zeros.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, params=None):</span>
<span class="sd">                Perform imputation by replacing missing values with zeros.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;test&quot;</span>

<div class="viewcode-block" id="Imputation.Statistics.Test.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.Test.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Impute missing values by replacing them with zeros.</span>
<span class="sd">                Template for adding external new algorithm</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Dictionary of algorithm parameters (default is None).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : ZeroImpute</span>
<span class="sd">                    The object with `recov_data` set.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.test</span><span class="w"> </span><span class="kn">import</span> <span class="n">zero_impute</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">zero_impute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.Statistics.Interpolation">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.Interpolation">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">Interpolation</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Interpolation class to impute missing values with interpolation-based algorithm</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, params=None):</span>
<span class="sd">                Perform imputation by replacing missing values with interpolation-based algorithm</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;interpolation&quot;</span>

<div class="viewcode-block" id="Imputation.Statistics.Interpolation.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.Interpolation.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Impute missing values by replacing them with the interpolation-based algorithm</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the interpolation algorithm, if None, default ones are loaded.</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : Interpolation</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; interpolation_imputer = Imputation.Statistics.Interpolation(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; interpolation_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; interpolation_imputer.impute(user_def=True, params={&quot;method&quot;:&quot;linear&quot;, &quot;poly_order&quot;:2})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; interpolation_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = interpolation_imputer.recov_data</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.interpolation</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpolation</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">method</span><span class="p">,</span> <span class="n">poly_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">method</span><span class="p">,</span> <span class="n">poly_order</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">interpolation</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">poly_order</span><span class="o">=</span><span class="n">poly_order</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="Imputation.Statistics.KNNImpute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.KNNImpute">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">KNNImpute</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            KNNImpute class to impute missing values with K-Nearest Neighbor algorithm</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, params=None):</span>
<span class="sd">                Perform imputation by replacing missing values with K-Nearest Neighbor</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;knn_impute&quot;</span>

<div class="viewcode-block" id="Imputation.Statistics.KNNImpute.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.Statistics.KNNImpute.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Impute missing values by replacing them with the K-Nearest Neighbor value</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the KNNImpute algorithm, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        k : int, optional</span>
<span class="sd">                            Number of nearest neighbor (default is 5).</span>
<span class="sd">                        weights : str, optional</span>
<span class="sd">                            &quot;uniform&quot; for mean, &quot;distance&quot; for inverse-distance weighting.</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : KNNImpute</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; knn_imputer = Imputation.Statistics.KNNImpute(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; knn_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; knn_imputer.impute(user_def=True, params={&#39;k&#39;: 5, &#39;weights&#39;: &quot;uniform&quot;})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; knn_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = knn_imputer.recov_data</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.knn</span><span class="w"> </span><span class="kn">import</span> <span class="n">knn</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">k</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">k</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="n">k</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">knn</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>
</div>






<div class="viewcode-block" id="Imputation.MatrixCompletion">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">MatrixCompletion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class containing imputation algorithms for matrix decomposition methods.</span>

<span class="sd">        Subclasses</span>
<span class="sd">        ----------</span>
<span class="sd">        CDRec :</span>
<span class="sd">            Imputation method using Centroid Decomposition.</span>
<span class="sd">        IterativeSVD :</span>
<span class="sd">            Imputation method using Iterative Singular Value Decomposition.</span>
<span class="sd">        GROUSE :</span>
<span class="sd">            Imputation method using Grassmannian Rank-One Update Subspace Estimation.</span>
<span class="sd">        ROSL :</span>
<span class="sd">            Imputation method using Robust Online Subspace Learning.</span>
<span class="sd">        SoftImpute :</span>
<span class="sd">            Imputation method using Soft Impute algorithm.</span>
<span class="sd">        SPIRIT :</span>
<span class="sd">            Imputation method using Streaming Pattern Discovery in Multiple Time-Series.</span>
<span class="sd">        SVT :</span>
<span class="sd">            Imputation method using Singular Value Thresholding algorithm.</span>
<span class="sd">        TRMF :</span>
<span class="sd">            Imputation method using Temporal Regularized Matrix Factorization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Imputation.MatrixCompletion.CDRec">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.CDRec">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">CDRec</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            CDRec class to impute missing values using Centroid Decomposition (CDRec).</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the CDRec algorithm.</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ cdrec.impute(params={&#39;rank&#39;: 3, &#39;epsilon&#39;: 1e-06, &#39;iterations&#39;: 100})</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;cdrec&quot;</span>

<div class="viewcode-block" id="Imputation.MatrixCompletion.CDRec.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.CDRec.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the CDRec algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the CDRec algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        rank : int</span>
<span class="sd">                            Rank of matrix reduction, which should be higher than 1 and smaller than the number of series.</span>
<span class="sd">                        epsilon : float</span>
<span class="sd">                            The learning rate used for the algorithm.</span>
<span class="sd">                        iterations : int</span>
<span class="sd">                            The number of iterations to perform.</span>

<span class="sd">                    **Auto-ML parameters:**</span>

<span class="sd">                        input_data : numpy.ndarray</span>
<span class="sd">                            The original time series dataset without contamination.</span>
<span class="sd">                        optimizer : str</span>
<span class="sd">                            The optimizer to use for parameter optimization. Valid values are &quot;bayesian&quot;, &quot;greedy&quot;, &quot;pso&quot;, or &quot;sh&quot;.</span>
<span class="sd">                        options : dict, optional</span>
<span class="sd">                            Optional parameters specific to the optimizer.</span>

<span class="sd">                        **Bayesian:**</span>

<span class="sd">                            n_calls : int, optional</span>
<span class="sd">                                Number of calls to the objective function. Default is 3.</span>
<span class="sd">                            metrics : list, optional</span>
<span class="sd">                                List of selected metrics to consider for optimization. Default is [&quot;RMSE&quot;].</span>
<span class="sd">                            n_random_starts : int, optional</span>
<span class="sd">                                Number of initial calls to the objective function, from random points. Default is 50.</span>
<span class="sd">                            acq_func : str, optional</span>
<span class="sd">                                Acquisition function to minimize over the Gaussian prior. Valid values: &#39;LCB&#39;, &#39;EI&#39;, &#39;PI&#39;, &#39;gp_hedge&#39; (default is &#39;gp_hedge&#39;).</span>

<span class="sd">                        **Greedy:**</span>

<span class="sd">                            n_calls : int, optional</span>
<span class="sd">                                Number of calls to the objective function. Default is 3.</span>
<span class="sd">                            metrics : list, optional</span>
<span class="sd">                                List of selected metrics to consider for optimization. Default is [&quot;RMSE&quot;].</span>

<span class="sd">                        **PSO:**</span>

<span class="sd">                            n_particles : int, optional</span>
<span class="sd">                                Number of particles used.</span>
<span class="sd">                            c1 : float, optional</span>
<span class="sd">                                PSO learning coefficient c1 (personal learning).</span>
<span class="sd">                            c2 : float, optional</span>
<span class="sd">                                PSO learning coefficient c2 (global learning).</span>
<span class="sd">                            w : float, optional</span>
<span class="sd">                                PSO inertia weight.</span>
<span class="sd">                            iterations : int, optional</span>
<span class="sd">                                Number of iterations for the optimization.</span>
<span class="sd">                            n_processes : int, optional</span>
<span class="sd">                                Number of processes during optimization.</span>

<span class="sd">                        **Successive Halving (SH):**</span>

<span class="sd">                            num_configs : int, optional</span>
<span class="sd">                                Number of configurations to try.</span>
<span class="sd">                            num_iterations : int, optional</span>
<span class="sd">                                Number of iterations to run the optimization.</span>
<span class="sd">                            reduction_factor : int, optional</span>
<span class="sd">                                Reduction factor for the number of configurations kept after each iteration.</span>


<span class="sd">                        **RAY TUNE (ray_tune):**</span>

<span class="sd">                            n_calls : int, optional</span>
<span class="sd">                                Number of calls to the objective function (default is 10).</span>
<span class="sd">                            max_concurrent_trials : int, optional</span>
<span class="sd">                                Number of trials run in parallel, related to your total memory / cpu / gpu (default is 2).</span>
<span class="sd">                                Please increase the value if you have more resources</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : CDRec</span>
<span class="sd">                    CDRec object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; cdrec_imputer = Imputation.MatrixCompletion.CDRec(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; cdrec_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; cdrec_imputer.impute(user_def=True, params={&#39;rank&#39;: 3, &#39;epsilon&#39;: 1e-06, &#39;iterations&#39;: 100})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; cdrec_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;bayesian&quot;, &quot;options&quot;: {&quot;n_calls&quot;: 2}})  # automl with bayesian</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = cdrec_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Khayati, M., Cudr-Mauroux, P. &amp; Bhlen, M.H. Scalable recovery of missing blocks in time series with high and low cross-correlations. Knowl Inf Syst 62, 22572280 (2020). https://doi.org/10.1007/s10115-019-01421-7</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.cdrec</span><span class="w"> </span><span class="kn">import</span> <span class="n">cdrec</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rank</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rank</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">cdrec</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">truncation_rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.MatrixCompletion.IterativeSVD">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.IterativeSVD">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">IterativeSVD</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            IterativeSVD class to impute missing values using Iterative SVD.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the Iterative SDV algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;iterative_svd&quot;</span>

<div class="viewcode-block" id="Imputation.MatrixCompletion.IterativeSVD.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.IterativeSVD.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the Iterative SVD algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                 user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the Iterative SVD algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        rank : int</span>
<span class="sd">                            Rank of matrix reduction, which should be higher than 1 and smaller than the number of series.</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : IterativeSVD</span>
<span class="sd">                    IterativeSVD object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; i_svd_imputer = Imputation.MatrixCompletion.IterativeSVD(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; i_svd_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; i_svd_imputer.impute(params={&#39;rank&#39;: 5}) # user-defined  &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; i_svd_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = i_svd_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Olga Troyanskaya, Michael Cantor, Gavin Sherlock, Pat Brown, Trevor Hastie, Robert Tibshirani, David Botstein, Russ B. Altman, Missing value estimation methods for DNA microarrays , Bioinformatics, Volume 17, Issue 6, June 2001, Pages 520525, https://doi.org/10.1093/bioinformatics/17.6.520</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.iterative_svd</span><span class="w"> </span><span class="kn">import</span> <span class="n">iterative_svd</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rank</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="n">rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">iterative_svd</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">truncation_rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.MatrixCompletion.GROUSE">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.GROUSE">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">GROUSE</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            GROUSE class to impute missing values using GROUSE.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the GROUSE algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;grouse&quot;</span>

<div class="viewcode-block" id="Imputation.MatrixCompletion.GROUSE.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.GROUSE.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the GROUSE algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the GROUSE algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        max_rank : int</span>
<span class="sd">                            Max rank of matrix reduction, which should be higher than 1 and smaller than the number of series.</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : GROUSE</span>
<span class="sd">                    GROUSE object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; grouse_imputer = Imputation.MatrixCompletion.GROUSE(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; grouse_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; grouse_imputer.impute(params={&#39;max_rank&#39;: 5}) # user-defined  &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; grouse_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = grouse_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                D. Zhang and L. Balzano. Global convergence of a grassmannian gradient descent algorithm for subspace estimation. In Proceedings of the 19th International Conference on Artificial Intelligence and Statistics, AISTATS 2016, Cadiz, Spain, May 9-11, 2016, pages 14601468, 2016.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.grouse</span><span class="w"> </span><span class="kn">import</span> <span class="n">grouse</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">max_rank</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="n">max_rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">max_rank</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">grouse</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">max_rank</span><span class="o">=</span><span class="n">max_rank</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.MatrixCompletion.ROSL">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.ROSL">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">ROSL</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            ROSL class to impute missing values using Robust Online Subspace Learning algorithm.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the ROSL algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;rosl&quot;</span>

<div class="viewcode-block" id="Imputation.MatrixCompletion.ROSL.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.ROSL.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the ROSL algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the ROSL algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                         rank : int</span>
<span class="sd">                            The rank of the low-dimensional subspace for matrix decomposition.</span>
<span class="sd">                            Must be greater than 0 and less than or equal to the number of columns in the matrix.</span>
<span class="sd">                         regularization : float</span>
<span class="sd">                            The regularization parameter to control the trade-off between reconstruction accuracy and robustness.</span>
<span class="sd">                            Higher values enforce sparsity or robustness against noise in the data.</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : ROSL</span>
<span class="sd">                    ROSL object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; rosl_imputer = Imputation.MatrixCompletion.ROSL(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; rosl_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; rosl_imputer.impute(params={&#39;rank&#39;: 5, &#39;regularization&#39;: 10}) # user-defined  &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; rosl_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = rosl_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                X. Shu, F. Porikli, and N. Ahuja. Robust orthonormal subspace learning: Efficient recovery of corrupted low-rank matrices. In 2014 IEEE Conference on Computer Vision and Pattern Recognition, CVPR 2014, Columbus, OH, USA, June 23-28, 2014, pages 38743881, 2014.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.rosl</span><span class="w"> </span><span class="kn">import</span> <span class="n">rosl</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rank</span><span class="p">,</span> <span class="n">regularization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rank</span><span class="p">,</span> <span class="n">regularization</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="n">rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">rosl</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">regularization</span><span class="o">=</span><span class="n">regularization</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.MatrixCompletion.SoftImpute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.SoftImpute">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">SoftImpute</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SoftImpute class to impute missing values using Soft Impute algorithm.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the Soft Impute algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;soft_impute&quot;</span>

<div class="viewcode-block" id="Imputation.MatrixCompletion.SoftImpute.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.SoftImpute.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the Soft Impute algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the Soft Impute algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                         max_rank : int</span>
<span class="sd">                            The max rank of the low-dimensional subspace for matrix decomposition.</span>
<span class="sd">                            Must be greater than 0 and less than or equal to the number of columns in the matrix.</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : SoftImpute</span>
<span class="sd">                    SoftImpute object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; soft_impute_imputer = Imputation.MatrixCompletion.SoftImpute(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; soft_impute_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; soft_impute_imputer.impute(params={&#39;max_rank&#39;: 5}) # user-defined  &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; soft_impute_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = soft_impute_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                R. Mazumder, T. Hastie, and R. Tibshirani. Spectral regularization algorithms for learning large incomplete matrices. Journal of Machine Learning Research, 11:22872322, 2010.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.soft_impute</span><span class="w"> </span><span class="kn">import</span> <span class="n">soft_impute</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">max_rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="n">max_rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">max_rank</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">soft_impute</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">max_rank</span><span class="o">=</span><span class="n">max_rank</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="Imputation.MatrixCompletion.SPIRIT">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.SPIRIT">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">SPIRIT</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SPIRIT class to impute missing values using SPIRIT algorithm.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the SPIRIT algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;spirit&quot;</span>

<div class="viewcode-block" id="Imputation.MatrixCompletion.SPIRIT.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.SPIRIT.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the SPIRIT algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the SPIRIT algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        k : int</span>
<span class="sd">                            The number of eigencomponents (principal components) to retain for dimensionality reduction.</span>
<span class="sd">                            Example: 2, 5, 10.</span>
<span class="sd">                        w : int</span>
<span class="sd">                            The window size for capturing temporal dependencies.</span>
<span class="sd">                            Example: 5 (short-term), 20 (long-term).</span>
<span class="sd">                        lambda_value : float</span>
<span class="sd">                            The forgetting factor controlling how quickly past data is &quot;forgotten&quot;.</span>
<span class="sd">                            Example: 0.8 (fast adaptation), 0.95 (stable systems).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : SPIRIT</span>
<span class="sd">                    SPIRIT object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; spirit_imputer = Imputation.MatrixCompletion.SPIRIT(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; spirit_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; spirit_imputer.impute(params={&#39;k&#39;: 2, &#39;w&#39;: 5, &#39;lambda_value&#39;: 0.85}) # user-defined  &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; spirit_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = spirit_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                S. Papadimitriou, J. Sun, and C. Faloutsos. Streaming pattern discovery in multiple time-series. In Proceedings of the 31st International Conference on Very Large Data Bases, Trondheim, Norway, August 30 - September 2, 2005, pages 697708, 2005.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.spirit</span><span class="w"> </span><span class="kn">import</span> <span class="n">spirit</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">lambda_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">lambda_value</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="n">k</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">spirit</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">lambda_value</span><span class="o">=</span><span class="n">lambda_value</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.MatrixCompletion.SVT">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.SVT">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">SVT</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SVT class to impute missing values using Singular Value Thresholding algorithm.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the SVT algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;svt&quot;</span>

<div class="viewcode-block" id="Imputation.MatrixCompletion.SVT.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.SVT.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the SVT algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the SVT algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        tau : float</span>
<span class="sd">                            The thresholding parameter for singular values. Controls how singular values are shrunk during the decomposition process.</span>
<span class="sd">                            Larger values encourage a sparser, lower-rank solution, while smaller values retain more detail.</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : SVT</span>
<span class="sd">                    SVT object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; svt_imputer = Imputation.MatrixCompletion.SVT(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; svt_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; svt_imputer.impute(params={&#39;tau&#39;: 1}) # user-defined  &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; svt_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = svt_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                J. Cai, E. J. Cands, and Z. Shen. A singular value thresholding algorithm for matrix completion. SIAM Journal on Optimization, 20(4):19561982, 2010. [8] J. Cambronero, J. K. Feser, M. J. Smith, and</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.svt</span><span class="w"> </span><span class="kn">import</span> <span class="n">svt</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tau</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">svt</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.MatrixCompletion.TRMF">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.TRMF">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">TRMF</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            TRMF class to impute missing values using Temporal Regularized Matrix Factorization.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the TRMF algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;trmf&quot;</span>

<div class="viewcode-block" id="Imputation.MatrixCompletion.TRMF.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MatrixCompletion.TRMF.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the TRMF algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the TRMF algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        lags : array-like, optional</span>
<span class="sd">                            Set of lag indices to use in model.</span>
<span class="sd">                        K : int, optional</span>
<span class="sd">                            Length of latent embedding dimension</span>
<span class="sd">                        lambda_f : float, optional</span>
<span class="sd">                            Regularization parameter used for matrix F.</span>
<span class="sd">                        lambda_x : float, optional</span>
<span class="sd">                            Regularization parameter used for matrix X.</span>
<span class="sd">                        lambda_w : float, optional</span>
<span class="sd">                            Regularization parameter used for matrix W.</span>
<span class="sd">                        alpha : float, optional</span>
<span class="sd">                            Regularization parameter used for make the sum of lag coefficient close to 1.</span>
<span class="sd">                            That helps to avoid big deviations when forecasting.</span>
<span class="sd">                        eta : float, optional</span>
<span class="sd">                            Regularization parameter used for X when undercovering autoregressive dependencies.</span>
<span class="sd">                        max_iter : int, optional</span>
<span class="sd">                            Number of iterations of updating matrices F, X and W.</span>
<span class="sd">                        logs : bool, optional</span>
<span class="sd">                            Whether to log the execution time (default is True).</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : TRMF</span>
<span class="sd">                    TRMF object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; trmf_imputer = Imputation.MatrixCompletion.TRMF(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; trmf_imputer.impute()</span>
<span class="sd">                    &gt;&gt;&gt; trmf_imputer.impute(params={&quot;lags&quot;:[], &quot;K&quot;:-1, &quot;lambda_f&quot;:1.0, &quot;lambda_x&quot;:1.0, &quot;lambda_w&quot;:1.0, &quot;eta&quot;:1.0, &quot;alpha&quot;:1000.0, &quot;max_iter&quot;:100})</span>
<span class="sd">                    &gt;&gt;&gt; trmf_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = trmf_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                H.-F. Yu, N. Rao, and I. S. Dhillon, &quot;Temporal Regularized Matrix Factorization for High-dimensional Time Series Prediction,&quot; in *Advances in Neural Information Processing Systems*, vol. 29, 2016. [Online]. Available: https://proceedings.neurips.cc/paper_files/paper/2016/file/85422afb467e9456013a2a51d4dff702-Paper.pdf</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.trmf</span><span class="w"> </span><span class="kn">import</span> <span class="n">trmf</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">lags</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">lambda_f</span><span class="p">,</span> <span class="n">lambda_x</span><span class="p">,</span> <span class="n">lambda_w</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lags</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">lambda_f</span><span class="p">,</span> <span class="n">lambda_x</span><span class="p">,</span> <span class="n">lambda_w</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">trmf</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">lambda_f</span><span class="o">=</span><span class="n">lambda_f</span><span class="p">,</span> <span class="n">lambda_x</span><span class="o">=</span><span class="n">lambda_x</span><span class="p">,</span> <span class="n">lambda_w</span><span class="o">=</span><span class="n">lambda_w</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>
</div>






<div class="viewcode-block" id="Imputation.MachineLearning">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MachineLearning">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">MachineLearning</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class containing imputation algorithms for pattern-based methods.</span>

<span class="sd">        Subclasses</span>
<span class="sd">        ----------</span>
<span class="sd">        MissForest :</span>
<span class="sd">            Imputation method using Miss Forest (MissForest)</span>
<span class="sd">        MICE :</span>
<span class="sd">            Imputation method using Multivariate imputation of chained equations (MICE).</span>
<span class="sd">        IIM :</span>
<span class="sd">            Imputation method using Iterative Imputation with Metric Learning (IIM).</span>
<span class="sd">        XGBOOST :</span>
<span class="sd">            Imputation method using Scalable Tree Boosting System (XGBOOST).</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Imputation.MachineLearning.MissForest">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MachineLearning.MissForest">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">MissForest</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MissForest class to impute missing values with Miss Forest.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the Miss Forest algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;miss_forest&quot;</span>

<div class="viewcode-block" id="Imputation.MachineLearning.MissForest.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MachineLearning.MissForest.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the Miss Forest algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the miss forest algorithm, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        alpha : float, optional</span>
<span class="sd">                            Trade-off parameter controlling the contribution of contextual matrix</span>
<span class="sd">                            and time-series. If alpha = 0, network is ignored. (default 0.5)</span>
<span class="sd">                        beta : float, optional</span>
<span class="sd">                            Regularization parameter for sparsity. (default 0.1)</span>
<span class="sd">                        L : int, optional</span>
<span class="sd">                            Hidden dimension size. (default 10)</span>
<span class="sd">                        n_cl : int, optional</span>
<span class="sd">                            Number of clusters. (default 1)</span>
<span class="sd">                        max_iteration : int, optional</span>
<span class="sd">                            Maximum number of iterations for convergence. (default 20)</span>
<span class="sd">                        tol : float, optional</span>
<span class="sd">                            Tolerance for early stopping criteria.  (default 5)</span>
<span class="sd">                        random_init : bool, optional</span>
<span class="sd">                            Whether to use random initialization for latent variables. (default False)</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : MissForest</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; mf_imputer = Imputation.MachineLearning.MissForest(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; mf_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mf_imputer.impute(user_def=True, params={&quot;n_estimators&quot;:10, &quot;max_iter&quot;:3, &quot;max_features&quot;:&quot;sqrt&quot;, &quot;seed&quot;: 42})  # user defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mf_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = mf_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Daniel J. Stekhoven, Peter Bhlmann, MissForestnon-parametric missing value imputation for mixed-type data, Bioinformatics, Volume 28, Issue 1, January 2012, Pages 112118, https://doi.org/10.1093/bioinformatics/btr597</span>
<span class="sd">                https://github.com/yuenshingyan/MissForest</span>
<span class="sd">                https://pypi.org/project/MissForest/</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.miss_forest</span><span class="w"> </span><span class="kn">import</span> <span class="n">miss_forest</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">n_estimators</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">max_features</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_estimators</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">max_features</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">miss_forest</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">n_estimators</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">max_features</span><span class="o">=</span><span class="n">max_features</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="Imputation.MachineLearning.MICE">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MachineLearning.MICE">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">MICE</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MICE class to impute missing values with Multivariate imputation of chained equations (MICE).</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the MICE algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;mice&quot;</span>

<div class="viewcode-block" id="Imputation.MachineLearning.MICE.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MachineLearning.MICE.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the MICE algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True). \n</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the MICE algorithm, if None, default ones are loaded. \n</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        max_iter : int, optional</span>
<span class="sd">                            Maximum number of imputation rounds to perform before returning the imputations computed during the final round. (default is 3). \n</span>
<span class="sd">                        tol : float, optional</span>
<span class="sd">                            Tolerance of the stopping condition. (default is 0.001). \n</span>
<span class="sd">                        initial_strategy : str, optional</span>
<span class="sd">                            Which strategy to use to initialize the missing values. {mean, median, most_frequent, constant} (default is &quot;means&quot;). \n</span>
<span class="sd">                        seed : int, optional</span>
<span class="sd">                            The seed of the pseudo random number generator to use. Randomizes selection of estimator features (default is 42). \n</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                    self : MICE</span>
<span class="sd">                        The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; mice_imputer = Imputation.MachineLearning.MICE(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; mice_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mice_imputer.impute(user_def=True, params={&quot;max_iter&quot;:3, &quot;tol&quot;:0.001, &quot;initial_strategy&quot;:&quot;mean&quot;, &quot;seed&quot;: 42})  # user defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mice_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = mice_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                P. Royston and I. R. White. Multiple Imputation by Chained Equations (MICE): Implementation in Stata. Journal of Statistical Software, 45(4):120, 2011. Available: https://www.jstatsoft.org/index.php/jss/article/view/v045i04.</span>
<span class="sd">                Stef van Buuren, Karin Groothuis-Oudshoorn (2011). mice: Multivariate Imputation by Chained Equations in R. Journal of Statistical Software 45: 1-67.</span>
<span class="sd">                S. F. Buck, (1960). A Method of Estimation of Missing Values in Multivariate Data Suitable for use with an Electronic Computer. Journal of the Royal Statistical Society 22(2): 302-306.</span>
<span class="sd">                https://scikit-learn.org/stable/modules/generated/sklearn.impute.IterativeImputer.html#sklearn.impute.IterativeImputer</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.mice</span><span class="w"> </span><span class="kn">import</span> <span class="n">mice</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">initial_strategy</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">initial_strategy</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">mice</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">initial_strategy</span><span class="o">=</span><span class="n">initial_strategy</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.MachineLearning.XGBOOST">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MachineLearning.XGBOOST">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">XGBOOST</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            XGBOOST class to impute missing values with Extreme Gradient Boosting (XGBOOST).</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the XGBOOST algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;xgboost&quot;</span>

<div class="viewcode-block" id="Imputation.MachineLearning.XGBOOST.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MachineLearning.XGBOOST.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the XGBOOST algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the xgboost algorithm, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        n_estimators : int, optional</span>
<span class="sd">                            The number of trees in the Random Forest model used for imputation (default is 10).</span>
<span class="sd">                        seed : int, optional</span>
<span class="sd">                            The seed of the pseudo random number generator to use. Randomizes selection of estimator features (default is 42).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : XGBOOST</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; mxgboost_imputer = Imputation.MachineLearning.XGBOOST(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; mxgboost_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mxgboost_imputer.impute(user_def=True, params={&quot;n_estimators&quot;:3, &quot;seed&quot;: 42})  # user defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mxgboost_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = mxgboost_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Tianqi Chen and Carlos Guestrin. 2016. XGBoost: A Scalable Tree Boosting System. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD &#39;16). Association for Computing Machinery, New York, NY, USA, 785794. https://doi.org/10.1145/2939672.2939785</span>
<span class="sd">                https://dl.acm.org/doi/10.1145/2939672.2939785</span>
<span class="sd">                https://medium.com/@tzhaonj/imputing-missing-data-using-xgboost-802757cace6d</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.xgboost</span><span class="w"> </span><span class="kn">import</span> <span class="n">xgboost</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">n_estimators</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_estimators</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="n">n_estimators</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">xgboost</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">n_estimators</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.MachineLearning.IIM">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MachineLearning.IIM">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">IIM</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            IIM class to impute missing values using Iterative Imputation with Metric Learning (IIM).</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the IIM algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;iim&quot;</span>

<div class="viewcode-block" id="Imputation.MachineLearning.IIM.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.MachineLearning.IIM.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the IIM algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the IIM algorithm, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        learning_neighbours : int</span>
<span class="sd">                            Number of nearest neighbors for learning.</span>
<span class="sd">                        algo_code : str</span>
<span class="sd">                            Unique code for the algorithm configuration.</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : IIM</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; iim_imputer = Imputation.MachineLearning.IIM(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; iim_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; iim_imputer.impute(user_def=True, params={&#39;learning_neighbors&#39;: 10})  # user-defined  &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; iim_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;bayesian&quot;, &quot;options&quot;: {&quot;n_calls&quot;: 2}})  # automl with bayesian</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = iim_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                A. Zhang, S. Song, Y. Sun and J. Wang, &quot;Learning Individual Models for Imputation,&quot; 2019 IEEE 35th International Conference on Data Engineering (ICDE), Macao, China, 2019, pp. 160-171, doi: 10.1109/ICDE.2019.00023.</span>
<span class="sd">                keywords: {Data models;Adaptation models;Computational modeling;Predictive models;Numerical models;Aggregates;Regression tree analysis;Missing values;Data imputation}</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.iim</span><span class="w"> </span><span class="kn">import</span> <span class="n">iim</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">learning_neighbours</span><span class="p">,</span> <span class="n">algo_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">learning_neighbours</span><span class="p">,</span> <span class="n">algo_code</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">iim</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">number_neighbor</span><span class="o">=</span><span class="n">learning_neighbours</span><span class="p">,</span> <span class="n">algo_code</span><span class="o">=</span><span class="n">algo_code</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>
</div>






<div class="viewcode-block" id="Imputation.PatternSearch">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.PatternSearch">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">PatternSearch</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class containing imputation algorithms for pattern-based methods.</span>

<span class="sd">        Subclasses</span>
<span class="sd">        ----------</span>
<span class="sd">        STMVL :</span>
<span class="sd">            Imputation method using Spatio-Temporal Matrix Variational Learning (STMVL).</span>

<span class="sd">        DynaMMo :</span>
<span class="sd">            Imputation method using Dynamic Multi-Mode modeling with Missing Observations algorithm (DynaMMo).</span>

<span class="sd">        TKCM :</span>
<span class="sd">            TKCM class to impute missing values using Tensor Kernelized Coupled Matrix Completion algorithm. (TKCM).</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Imputation.PatternSearch.STMVL">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.PatternSearch.STMVL">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">STMVL</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            STMVL class to impute missing values using Spatio-Temporal Matrix Variational Learning (STMVL).</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the STMVL algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;stmvl&quot;</span>

<div class="viewcode-block" id="Imputation.PatternSearch.STMVL.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.PatternSearch.STMVL.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the STMVL algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the STMVL algorithm, if None, default ones are loaded.</span>

<span class="sd">                    - window_size : int</span>
<span class="sd">                        The size of the temporal window for imputation.</span>
<span class="sd">                    - gamma : float</span>
<span class="sd">                        Smoothing parameter for temporal weights.</span>
<span class="sd">                    - alpha : float</span>
<span class="sd">                        Power for spatial weights.</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : STMVL</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; stmvl_imputer = Imputation.PatternSearch.STMVL(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; stmvl_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; stmvl_imputer.impute(user_def=True, params={&#39;window_size&#39;: 7, &#39;learning_rate&#39;:0.01, &#39;gamma&#39;:0.85, &#39;alpha&#39;: 7})  # user-defined  &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; stmvl_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;bayesian&quot;, &quot;options&quot;: {&quot;n_calls&quot;: 2}})  # automl with bayesian</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = stmvl_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Yi, X., Zheng, Y., Zhang, J., &amp; Li, T. ST-MVL: Filling Missing Values in Geo-Sensory Time Series Data.</span>
<span class="sd">                School of Information Science and Technology, Southwest Jiaotong University; Microsoft Research; Shenzhen Institutes of Advanced Technology, Chinese Academy of Sciences.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.stmvl</span><span class="w"> </span><span class="kn">import</span> <span class="n">stmvl</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">window_size</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">window_size</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">stmvl</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.PatternSearch.DynaMMo">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.PatternSearch.DynaMMo">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">DynaMMo</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            DynaMMo class to impute missing values using Dynamic Multi-Mode modeling with Missing Observations algorithm.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the DynaMMo algorithm.</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ dynammo.impute(params={&#39;h&#39;: 3, &#39;max_iteration&#39;: 100, &#39;approximation&#39;: True})</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;dynammo&quot;</span>

<div class="viewcode-block" id="Imputation.PatternSearch.DynaMMo.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.PatternSearch.DynaMMo.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the DynaMMo algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the DynaMMo algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        h : int</span>
<span class="sd">                            The time window (H) parameter for modeling temporal dynamics.</span>
<span class="sd">                        max_iteration : int</span>
<span class="sd">                            The maximum number of iterations for the imputation process.</span>
<span class="sd">                        approximation : bool</span>
<span class="sd">                            If True, enables faster approximate processing.</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : DynaMMo</span>
<span class="sd">                    DynaMMo object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; dynammo_imputer = Imputation.PatternSearch.DynaMMo(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; dynammo_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; dynammo_imputer.impute(params={&#39;h&#39;: 3, &#39;max_iteration&#39;: 100, &#39;approximation&#39;: True}) # user-defined  &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; dynammo_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = dynammo_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                L. Li, J. McCann, N. S. Pollard, and C. Faloutsos. Dynammo: mining and summarization of coevolving sequences with missing values. In Proceedings of the 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, Paris, France, June 28 - July 1, 2009, pages 507516, 2009.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.dynammo</span><span class="w"> </span><span class="kn">import</span> <span class="n">dynammo</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">h</span><span class="p">,</span> <span class="n">max_iteration</span><span class="p">,</span> <span class="n">approximation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">h</span><span class="p">,</span> <span class="n">max_iteration</span><span class="p">,</span> <span class="n">approximation</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">dynammo</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">max_iteration</span><span class="o">=</span><span class="n">max_iteration</span><span class="p">,</span> <span class="n">approximation</span><span class="o">=</span><span class="n">approximation</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.PatternSearch.TKCM">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.PatternSearch.TKCM">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">TKCM</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            TKCM class to impute missing values using Tensor Kernelized Coupled Matrix Completion algorithm.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the TKCM algorithm.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;tkcm&quot;</span>

<div class="viewcode-block" id="Imputation.PatternSearch.TKCM.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.PatternSearch.TKCM.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the TKCM algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the TKCM algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        rank : int</span>
<span class="sd">                            The rank for matrix decomposition (must be greater than 1 and smaller than the number of series).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : TKCM</span>
<span class="sd">                    TKCM object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; tkcm_imputer = Imputation.PatternSearch.TKCM(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; tkcm_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; tkcm_imputer.impute(params={&#39;rank&#39;: 5})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; tkcm_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = tkcm_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                K. Wellenzohn, M. H. Bhlen, A. Digns, J. Gamper, and H. Mitterer. Continuous imputation of missing values in streams of pattern-determining time series. In Proceedings of the 20th International Conference on Extending Database Technology, EDBT 2017, Venice, Italy, March 21-24, 2017., pages 330341, 2017.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.tkcm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tkcm</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="n">rank</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">tkcm</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">DeepLearning</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class containing imputation algorithms for deep learning-based methods.</span>

<span class="sd">        Subclasses</span>
<span class="sd">        ----------</span>
<span class="sd">        MRNN :</span>
<span class="sd">            Imputation method using Multi-directional Recurrent Neural Networks (MRNN).</span>
<span class="sd">        BRITS :</span>
<span class="sd">            Imputation method using Bidirectional Recurrent Imputation for Time Series.</span>
<span class="sd">        DeepMVI :</span>
<span class="sd">            Imputation method using Deep Multivariate Imputation.</span>
<span class="sd">        MPIN :</span>
<span class="sd">            Imputation method using Multi-attribute Sensor Data Streams via Message Propagation.</span>
<span class="sd">        PRISTI :</span>
<span class="sd">            Imputation method using A Conditional Diffusion Framework for Spatiotemporal Imputation.</span>
<span class="sd">        MissNet :</span>
<span class="sd">            Imputation method using Mining of Switching Sparse Networks for Missing Value Imputation.</span>
<span class="sd">        GAIN :</span>
<span class="sd">            Imputation method using Generative Adversarial Nets for missing data imputation.</span>
<span class="sd">        GRIN :</span>
<span class="sd">            Imputation method using Graph Neural Networks for Multivariate Time Series Imputation.</span>
<span class="sd">        BayOTIDE :</span>
<span class="sd">            Imputation method using Bayesian Online Multivariate Time Series Imputation with functional decomposition.</span>
<span class="sd">        HKMF_T :</span>
<span class="sd">            Imputation method using Hankel Matrix Factorization to recover from blackouts in tagged time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<div class="viewcode-block" id="Imputation.DeepLearning.MRNN">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.MRNN">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">MRNN</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MRNN class to impute missing values using Multi-directional Recurrent Neural Networks (MRNN).</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the MRNN algorithm.</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ mrnn.impute(params={&quot;seq_len&quot;:24, &quot;epochs&quot;: 200, &quot;batch_size&quot;: 64, &quot;sliding_windows&quot;: 1 &quot;hidden_layer&quot;: 108, &quot;impute_weight&quot;: 0.3, &quot;num_workers&quot;:0})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Implemented from the BRITS baseline</span>

<span class="sd">            - Integration of JSON file generation inside the imputer module.</span>

<span class="sd">            - Addition of a custom loader (sliding-window strategy) for univariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - Addition of a custom loader (sampling strategy) for multivariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Addition of a reconstruction module to rebuild the full original imputed matrix (sum and average the windows (windows strategy) | merge the dimensions across samples (samples strategy)).</span>

<span class="sd">            - Reduction of the epochs parameter to 100 for performance reasons.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;mrnn&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.MRNN.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.MRNN.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the MRNN algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>

<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the MRNN algorithm, if None, default ones are loaded.</span>
<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                    seq_len : int</span>
<span class="sd">                        Length of the input sequence used by the model. Defines the number of time steps processed at once (default 24).</span>

<span class="sd">                    epoch : int</span>
<span class="sd">                        Number of epochs for training the model. Determines how many times the algorithm processes the entire dataset during training.</span>

<span class="sd">                    batch_size : int</span>
<span class="sd">                        Size of the batches used during training. Larger batch sizes can speed up training but may require more memory.</span>

<span class="sd">                    sliding_windows: int, optional</span>
<span class="sd">                            Stride between consecutive training windows (default is 1). If set to 0, the window size is equal to seq_len.</span>
<span class="sd">                            Use values  1 for univariate datasets (window strategy) and 0 for multivariate datasets (sample strategy).</span>

<span class="sd">                    hidden_layers : int</span>
<span class="sd">                        Number of units in the hidden layer of the model. Controls the capacity of the neural network to learn complex patterns.</span>

<span class="sd">                    impute_weight : float</span>
<span class="sd">                        Weight of the imputation term (default: 0.3).</span>

<span class="sd">                    num_workers: int, optional</span>
<span class="sd">                         Number of worker for multiprocess (default is 0).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : MRNN</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; mrnn_imputer = Imputation.DeepLearning.MRNN(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; mrnn_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mrnn_imputer.impute(params={&quot;seq_len&quot;:24, &quot;epochs&quot;: 200, &quot;batch_size&quot;: 64, &quot;sliding_windows&quot;: 1 &quot;hidden_layer&quot;: 108, &quot;impute_weight&quot;: 0.3, &quot;num_workers&quot;:0})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mrnn_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;bayesian&quot;, &quot;options&quot;: {&quot;n_calls&quot;: 2}})  # automl with bayesian</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = mrnn_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                J. Yoon, W. R. Zame and M. van der Schaar, &quot;Estimating Missing Data in Temporal Data Streams Using Multi-Directional Recurrent Neural Networks,&quot; in IEEE Transactions on Biomedical Engineering, vol. 66, no. 5, pp. 1477-1490, May 2019, doi: 10.1109/TBME.2018.2874712. keywords: {Time measurement;Interpolation;Estimation;Medical diagnostic imaging;Correlation;Recurrent neural networks;Biomedical measurement;Missing data;temporal data streams;imputation;recurrent neural nets}</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.mrnn</span><span class="w"> </span><span class="kn">import</span> <span class="n">mrnn</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">hidden_layer</span><span class="p">,</span> <span class="n">impute_weight</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">hidden_layer</span><span class="p">,</span> <span class="n">impute_weight</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">mrnn</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="o">=</span><span class="n">sliding_windows</span><span class="p">,</span> <span class="n">hidden_layers</span><span class="o">=</span><span class="n">hidden_layer</span><span class="p">,</span> <span class="n">impute_weight</span><span class="o">=</span><span class="n">impute_weight</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.BRITS">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.BRITS">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">BRITS</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            BRITS class to impute missing values using Bidirectional Recurrent Imputation for Time Series</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the BRITS algorithm.</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ brits.impute(params={&quot;model&quot;: &quot;brits&quot;, &quot;seq_len&quot;:24, &quot;epochs&quot;: 200, &quot;batch_size&quot;: 64, &quot;sliding_windows&quot;: 1,  &quot;hidden_layer&quot;: 108, &quot;impute_weight&quot;: 0.3, &quot;num_workers&quot;:0})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Integration of JSON file generation inside the imputer module.</span>

<span class="sd">            - Addition of a custom loader (sliding-window strategy) for univariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - Addition of a custom loader (sampling strategy) for multivariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Addition of a reconstruction module to rebuild the full original imputed matrix (sum and average the windows (windows strategy) | merge the dimensions across samples (samples strategy)).</span>

<span class="sd">            - Reduction of the epochs parameter to 100 for performance reasons.</span>

<span class="sd">            - Selection of &quot;brits&quot; as the default model.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;brits&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.BRITS.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.BRITS.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the BRITS algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the BRITS algorithm, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        model : str</span>
<span class="sd">                            Specifies the type of model to use for the imputation. Options may include predefined models like &#39;brits&#39;, &#39;brits-i&#39;.</span>

<span class="sd">                        seq_len : int</span>
<span class="sd">                            Length of the input sequence used by the model. Defines the number of time steps processed at once (default 24).</span>

<span class="sd">                        epoch : int</span>
<span class="sd">                            Number of epochs for training the model. Determines how many times the algorithm processes the entire dataset during training.</span>

<span class="sd">                        batch_size : int</span>
<span class="sd">                            Size of the batches used during training. Larger batch sizes can speed up training but may require more memory.</span>

<span class="sd">                        sliding_windows: int, optional</span>
<span class="sd">                            Stride between consecutive training windows (default is 1). If set to 0, the window size is equal to seq_len.</span>
<span class="sd">                            Use values  1 for univariate datasets (window strategy) and 0 for multivariate datasets (sample strategy).</span>

<span class="sd">                        hidden_layers : int</span>
<span class="sd">                            Number of units in the hidden layer of the model. Controls the capacity of the neural network to learn complex patterns.</span>

<span class="sd">                        impute_weight : float</span>
<span class="sd">                            Weight of the imputation term (default: 0.3).</span>

<span class="sd">                        num_workers: int, optional</span>
<span class="sd">                             Number of worker for multiprocess (default is 0).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : BRITS</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; brits_imputer = Imputation.DeepLearning.BRITS(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; brits_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; brits_imputer.impute(params={&quot;model&quot;: &quot;brits&quot;, &quot;seq_len&quot;:24, &quot;epochs&quot;: 200, &quot;batch_size&quot;: 64, &quot;sliding_windows&quot;: 1,  &quot;hidden_layer&quot;: 108, &quot;impute_weight&quot;: 0.3, &quot;num_workers&quot;:0})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; brits_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = brits_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Cao, W., Wang, D., Li, J., Zhou, H., Li, L. &amp; Li, Y. BRITS: Bidirectional Recurrent Imputation for Time Series. Advances in Neural Information Processing Systems, 31 (2018). https://proceedings.neurips.cc/paper_files/paper/2018/file/734e6bfcd358e25ac1db0a4241b95651-Paper.pdf</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.brits</span><span class="w"> </span><span class="kn">import</span> <span class="n">brits</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">model</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">hidden_layer</span><span class="p">,</span> <span class="n">impute_weight</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">model</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">hidden_layer</span><span class="p">,</span> <span class="n">impute_weight</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">brits</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="o">=</span><span class="n">sliding_windows</span><span class="p">,</span> <span class="n">hidden_layers</span><span class="o">=</span><span class="n">hidden_layer</span><span class="p">,</span> <span class="n">impute_weight</span><span class="o">=</span><span class="n">impute_weight</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.DeepMVI">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.DeepMVI">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">DeepMVI</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            DeepMVI class to impute missing values using Deep Multivariate Imputation</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the DeepMVI algorithm.</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ deepmvi.impute(params={&quot;max_epoch&quot;: 1000, &quot;patience&quot;: 2, &quot;lr&quot;:0.001, &quot;batch_size&quot;:-1})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Added a safeguard to prevent a negative block_size when it cannot be computed automatically.</span>

<span class="sd">            - Added a safeguard to prevent a negative kernel_size when it cannot be computed automatically.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;deep_mvi&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.DeepMVI.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.DeepMVI.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.6</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the DeepMVI algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the DeepMVI algorithm, if None, default ones are loaded.</span>
<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        max_epoch : int, optional</span>
<span class="sd">                            Limit of training epoch (default is 1000)</span>

<span class="sd">                        patience : int, optional</span>
<span class="sd">                            Number of threshold error that can be crossed during the training (default is 2)</span>

<span class="sd">                        lr : float, optional</span>
<span class="sd">                            Learning rate of the training (default is 0.001)</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : DeepMVI</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; deep_mvi_imputer = Imputation.DeepLearning.DeepMVI(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; deep_mvi_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; deep_mvi_imputer.impute(params={&quot;max_epoch&quot;: 1000, &quot;patience&quot;: 2, &quot;lr&quot;:0.001, &quot;batch_size&quot;:-1})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; deep_mvi_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = deep_mvi_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                P. Bansal, P. Deshpande, and S. Sarawagi. Missing value imputation on multidimensional time series. arXiv preprint arXiv:2103.01600, 2023</span>
<span class="sd">                https://github.com/pbansal5/DeepMVI</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.deep_mvi</span><span class="w"> </span><span class="kn">import</span> <span class="n">deep_mvi</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_dl_split</span><span class="p">(</span><span class="n">split_ratio</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span>
                    <span class="k">return</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">max_epoch</span><span class="p">,</span> <span class="n">patience</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_epoch</span><span class="p">,</span> <span class="n">patience</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">deep_mvi</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">max_epoch</span><span class="o">=</span><span class="n">max_epoch</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.MPIN">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.MPIN">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">MPIN</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MPIN class to impute missing values using Multi-attribute Sensor Data Streams via Message Propagation algorithm.</span>
<span class="sd">            Need torch-cluster to work.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the MPIN algorithm.</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ mpin.impute(params={&quot;window&quot;: 6, &quot;incre_mode&quot;: &quot;alone&quot;, &quot;base&quot;: &quot;SAGE&quot;, &quot;epochs&quot;: 200, &quot;num_of_iteration&quot;: 5, &quot;k&quot;: 10})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Use the default dataloader that merges the dimensions for 2D dataset</span>

<span class="sd">            - Update the number of windows to be user-defined, and not based on seq_len.</span>

<span class="sd">            - Injected the missing values from ImputeGAP into the default dataset as original NaNs.</span>

<span class="sd">            - Addition of a reconstruction module to rebuild the full original imputed matrix (sum and average the windows (windows strategy) | merge the dimensions across samples (samples strategy)).</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;mpin&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.MPIN.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.MPIN.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the MPIN algorithm.</span>
<span class="sd">                Need torch-cluster to work.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>
<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the MPIN algorithm, if None, default ones are loaded.</span>
<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>

<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        incre_mode : str, optional</span>
<span class="sd">                            The mode of incremental learning. Options are: &#39;alone&#39;,  &#39;data&#39;, &#39;state&#39;, &#39;state+transfer&#39;, &#39;data+state&#39;, &#39;data+state+transfer&#39; (default is &quot;alone&quot;).</span>
<span class="sd">                        window : int, optional</span>
<span class="sd">                            The size of the sliding window for processing data streams (default is 2).</span>
<span class="sd">                        k : int, optional</span>
<span class="sd">                            The number of neighbors to consider during message propagation (default is 10).</span>
<span class="sd">                        lr : float, optional</span>
<span class="sd">                            The learning rate for optimizing the message propagation algorithm (default is 0.01).</span>
<span class="sd">                        weight_decay : float, optional</span>
<span class="sd">                            The weight decay (regularization) term to prevent overfitting during training (default is 0.1).</span>
<span class="sd">                        epochs : int, optional</span>
<span class="sd">                            The number of epochs to run the training process (default is 200).</span>
<span class="sd">                        num_of_iteration : int, optional</span>
<span class="sd">                            The number of iteration of the whole training (default is 5).</span>
<span class="sd">                        thre : float, optional</span>
<span class="sd">                            The threshold for considering a missing value as imputed (default is 0.25).</span>
<span class="sd">                        base : str, optional</span>
<span class="sd">                            The base model used for graph representation and message propagation. Common options include &quot;SAGE&quot; and &quot;GCN&quot; (default is &quot;SAGE&quot;).</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : MPIN</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; mpin_imputer = Imputation.DeepLearning.MPIN(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; mpin_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mpin_imputer.impute(params={&quot;window&quot;: 6, &quot;incre_mode&quot;: &quot;alone&quot;, &quot;base&quot;: &quot;SAGE&quot;, &quot;epochs&quot;: 200, &quot;num_of_iteration&quot;: 5, &quot;k&quot;: 10})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; mpin_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = mpin_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Li, X., Li, H., Lu, H., Jensen, C.S., Pandey, V. &amp; Markl, V. Missing Value Imputation for Multi-attribute Sensor Data Streams via Message Propagation (Extended Version). arXiv (2023). https://arxiv.org/abs/2311.07344</span>
<span class="sd">                https://github.com/XLI-2020/MPIN</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.mpin</span><span class="w"> </span><span class="kn">import</span> <span class="n">mpin</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">window</span><span class="p">,</span> <span class="n">incre_mode</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">num_of_iteration</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">window</span><span class="p">,</span> <span class="n">incre_mode</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">num_of_iteration</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="n">k</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">control_boundaries</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">window</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">mpin</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">incre_mode</span><span class="o">=</span><span class="n">incre_mode</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">num_of_iteration</span><span class="o">=</span><span class="n">num_of_iteration</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.PriSTI">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.PriSTI">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">PriSTI</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            PRISTI class to impute missing values using A Conditional Diffusion Framework for Spatiotemporal Imputation algorithm.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the PRISTI algorithm.</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ imputer.impute(params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;: 200, &quot;sliding_windows&quot;:1, &quot;target_strategy&quot;:&quot;random&quot;, &quot;nsamples&quot;: 100, &quot;num_workers&quot;:0})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Addition of a custom loader (sliding-window strategy) for univariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - Addition of a custom loader (sampling strategy) for multivariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Addition of a reconstruction module to rebuild the full original imputed matrix (sum and average the windows (windows strategy) | merge the dimensions across samples (samples strategy)).</span>

<span class="sd">            - Reduction of the epochs parameter to 20 and the nsamples parameter to 1 for performance reasons.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;pristi&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.PriSTI.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.PriSTI.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the PRISTI algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the PRISTI algorithm, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        seq_len : int, optional</span>
<span class="sd">                            Length of the input sequence for the encoder. If -1, it will be automatically determined (default: -1).</span>
<span class="sd">                            For PrisTI algorithm, if possible, set the seq_len=number_features</span>

<span class="sd">                        batch_size : int, optional</span>
<span class="sd">                            Number of samples per batch during training/inference. If -1, it will be auto-set (default: -1).</span>

<span class="sd">                        epochs : int, optional</span>
<span class="sd">                            Number of epoch for training the model (default: 10).</span>

<span class="sd">                        sliding_windows: int, optional</span>
<span class="sd">                            Stride between consecutive training windows (default is 1). If set to 0, the window size is equal to seq_len.</span>
<span class="sd">                            Use values  1 for univariate datasets (window strategy) and 0 for multivariate datasets (sample strategy).</span>

<span class="sd">                        target_strategy: str, optional</span>
<span class="sd">                            The strategy to use for targeting missing values pattern. Options include: &quot;mix&quot;, &quot;block&quot;, &quot;random&quot; (default is &quot;random&quot;).</span>

<span class="sd">                        nsamples: int, optional</span>
<span class="sd">                            Number of trajectories generated by the diffusion process (default: 1).</span>

<span class="sd">                        num_workers: int, optional</span>
<span class="sd">                             Number of worker for multiprocess (default is 0).</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : PRISTI</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; pristi_imputer = Imputation.DeepLearning.PriSTI(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; pristi_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; pristi_imputer.impute(params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;: 200, &quot;sliding_windows&quot;:1, &quot;target_strategy&quot;:&quot;random&quot;, &quot;nsamples&quot;: 100, &quot;num_workers&quot;:0})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; pristi_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # automl with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = pristi_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                M. Liu, H. Huang, H. Feng, L. Sun, B. Du and Y. Fu, &quot;PriSTI: A Conditional Diffusion Framework for Spatiotemporal Imputation,&quot; 2023 IEEE 39th International Conference on Data Engineering (ICDE), Anaheim, CA, USA, 2023, pp. 1927-1939, doi: 10.1109/ICDE55515.2023.00150.</span>
<span class="sd">                https://github.com/LMZZML/PriSTI</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.pristi</span><span class="w"> </span><span class="kn">import</span> <span class="n">pristi</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">target_strategy</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">target_strategy</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">pristi</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="o">=</span><span class="n">sliding_windows</span><span class="p">,</span> <span class="n">target_strategy</span><span class="o">=</span><span class="n">target_strategy</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.MissNet">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.MissNet">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">MissNet</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            MissNet class to impute missing values using Mining of Switching Sparse Networks for Missing Value</span>
<span class="sd">             Imputation in Multivariate Time Series.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the MissNet algorithm.</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ missnet.impute(params={&#39;n_components&#39;:15, &#39;alpha&#39;: 0.5, &#39;beta&#39;:0.1, &#39;n_cl&#39;: 1, &#39;max_iter&#39;:20, &#39;tol&#39;:5, &#39;random_init&#39;:False})</span>


<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Replace the experimental loop with the entire contaminated matrix.</span>

<span class="sd">            - Reduction of the iteration limit for performance reasons (may not converge).</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;miss_net&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.MissNet.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.MissNet.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.6</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the MissNet algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the MissNet algorithm, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                **Algorithm parameters:**</span>

<span class="sd">                    n_components : int</span>
<span class="sd">                        number of latent dimentions. (default 15)</span>

<span class="sd">                    alpha : float, optional</span>
<span class="sd">                        Trade-off parameter controlling the contribution of contextual matrix</span>
<span class="sd">                        and time-series. If alpha = 0, network is ignored. (default 0.5)</span>

<span class="sd">                    beta : float, optional</span>
<span class="sd">                        Regularization parameter for sparsity. (default 0.1)</span>

<span class="sd">                    L : int, optional</span>
<span class="sd">                        Hidden dimension size. (default 10)</span>

<span class="sd">                    n_cl : int, optional</span>
<span class="sd">                        Number of clusters. (default 1)</span>

<span class="sd">                    max_iter : int, optional</span>
<span class="sd">                        Maximum number of iterations for convergence. (default 20)</span>

<span class="sd">                    tol : float, optional</span>
<span class="sd">                        Tolerance for early stopping criteria.  (default 5)</span>

<span class="sd">                    random_init : bool, optional</span>
<span class="sd">                        Whether to use random initialization for latent variables. (default False)</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : MissNet</span>
<span class="sd">                    The object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; miss_net_imputer = Imputation.DeepLearning.MissNet(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; miss_net_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; miss_net_imputer.impute(user_def=True, params={&#39;n_components&#39;:15, &#39;alpha&#39;: 0.5, &#39;beta&#39;:0.1, &#39;n_cl&#39;: 1, &#39;max_iter&#39;:20, &#39;tol&#39;:5, &#39;random_init&#39;:False})  # user-defined &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; miss_net_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = miss_net_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Kohei Obata, Koki Kawabata, Yasuko Matsubara, and Yasushi Sakurai. 2024. Mining of Switching Sparse Networks for Missing Value Imputation in Multivariate Time Series. In Proceedings of the 30th ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD &#39;24). Association for Computing Machinery, New York, NY, USA, 22962306. https://doi.org/10.1145/3637528.3671760</span>
<span class="sd">                https://github.com/KoheiObata/MissNet/tree/main</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.miss_net</span><span class="w"> </span><span class="kn">import</span> <span class="n">miss_net</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">n_components</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">n_cl</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">random_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_components</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">n_cl</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">random_init</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">miss_net</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">n_cl</span><span class="o">=</span><span class="n">n_cl</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">random_init</span><span class="o">=</span><span class="n">random_init</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="Imputation.DeepLearning.GAIN">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.GAIN">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">GAIN</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            GAIN class to impute missing values using Missing Data Imputation using Generative Adversarial Nets,</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the GAIN algorithm.</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ gain.impute(params={&quot;batch_size&quot;:128, &quot;epochs&quot;:1000, &quot;alpha&quot;:100, &quot;hint_rate&quot;:0.9})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Introduction of data normalization beforehand (needed).</span>

<span class="sd">            - Adding a loop over generation of data to guarantee convergence.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;gain&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.GAIN.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.GAIN.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the GAIN algorithm.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the GAIN algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        batch_size : int, optional</span>
<span class="sd">                            Number of samples in each mini-batch during training. Default is 32.</span>
<span class="sd">                        hint_rate : float, optional</span>
<span class="sd">                            Probability of providing hints for the missing data during training. Default is 0.9.</span>
<span class="sd">                        alpha : float, optional</span>
<span class="sd">                            Hyperparameter that controls the balance between the adversarial loss and the reconstruction loss. Default is 10.</span>
<span class="sd">                        epoch : int, optional</span>
<span class="sd">                            Number of training epochs. Default is 100.</span>
<span class="sd">                        logs : bool, optional</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : GAIN</span>
<span class="sd">                    GAIN object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; gain_imputer = Imputation.DeepLearning.GAIN(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; gain_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; gain_imputer.impute(user_def=True, params={&quot;batch_size&quot;:128, &quot;epochs&quot;:1000, &quot;alpha&quot;:100, &quot;hint_rate&quot;:0.9})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; gain_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = gain_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                J. Yoon, J. Jordon, and M. van der Schaar, &quot;GAIN: Missing Data Imputation using Generative Adversarial Nets,&quot; CoRR, vol. abs/1806.02920, 2018. Available: http://arxiv.org/abs/1806.02920.</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.gain</span><span class="w"> </span><span class="kn">import</span> <span class="n">gain</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">hint_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">hint_rate</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">gain</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">hint_rate</span><span class="o">=</span><span class="n">hint_rate</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="Imputation.DeepLearning.GRIN">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.GRIN">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">GRIN</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            GRIN class to impute missing values using MULTIVARIATE TIME SERIES IMPUTATION BY GRAPH NEURAL NETWORKS.</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the GRIN</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ grin.impute(params={&quot;seq_len&quot;:1, &quot;sim_type&quot;:&quot;corr&quot;, &quot;epochs&quot;:50, &quot;batch_size&quot;:32, &quot;sliding_windows&quot;:1, &quot;alpha&quot;:10.0, &quot;patience&quot;:40, &quot;num_workers&quot;:0})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Addition of a custom loader (sliding-window strategy) for univariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - Addition of a custom loader (sampling strategy) for multivariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Addition of a reconstruction module to rebuild the full original imputed matrix (sum and average the windows (windows strategy) | merge the dimensions across samples (samples strategy)).</span>

<span class="sd">            - Adaptation of the node similarity graph either from the data or via fallback: if type=&#39;corr&#39;, compute a correlation-based adjacency from the time-series values.</span>

<span class="sd">            - Adaptation of distance data by computing a synthetic distance matrix from the time-series.</span>

<span class="sd">            - Automatic computation of seq_len and batch_size when not explicitly set.</span>

<span class="sd">            - Reduction of the epochs parameter to 30 for performance reasons.</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;grin&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.GRIN.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.GRIN.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the Multivariate Time Series Imputation by Graph Neural Networks</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the GRIN algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        seq_len : int, optional, default=1</span>
<span class="sd">                            Length of the input sequence used by the model. Defines the number of time steps inside each sample.</span>

<span class="sd">                        sim_type : string, optional, default=&quot;corr&quot;</span>
<span class="sd">                            Select the function used to compute the similarity measure: (uniform, corr, dcrnn, stcn)</span>

<span class="sd">                        epochs : int, optional, default=20</span>
<span class="sd">                                The maximum number of training epochs.</span>

<span class="sd">                        batch_size : int, optional, default=32</span>
<span class="sd">                            The number of samples per training batch.</span>

<span class="sd">                        alpha : float, optional, default=10.0</span>
<span class="sd">                            The weight assigned to the adversarial loss term during training.</span>

<span class="sd">                        patience : int, optional, default=4</span>
<span class="sd">                            Number of epochs without improvement before early stopping is triggered.</span>

<span class="sd">                        num_workers : int, optional, default=0</span>
<span class="sd">                            The number of worker processes for data loading.</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : GRIN</span>
<span class="sd">                    GRIN object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; grin_imputer = Imputation.DeepLearning.GRIN(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; grin_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; grin_imputer.impute(user_def=True, params={&quot;seq_len&quot;:1, &quot;sim_type&quot;:&quot;corr&quot;, &quot;epochs&quot;:50, &quot;batch_size&quot;:32, &quot;sliding_windows&quot;:1, &quot;alpha&quot;:10.0, &quot;patience&quot;:40, &quot;num_workers&quot;:0})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; grin_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = grin_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                A. Cini, I. Marisca, and C. Alippi, &quot;Multivariate Time Series Imputation by Graph Neural Networks,&quot; CoRR, vol. abs/2108.00298, 2021</span>
<span class="sd">                https://github.com/Graph-Machine-Learning-Group/grin</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.grin</span><span class="w"> </span><span class="kn">import</span> <span class="n">grin</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">sim_type</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">patience</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">sim_type</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">patience</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">grin</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">sim_type</span><span class="o">=</span><span class="n">sim_type</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="o">=</span><span class="n">sliding_windows</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.BayOTIDE">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.BayOTIDE">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">BayOTIDE</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            BayOTIDE class to impute missing values using Bayesian Online Multivariate Time series Imputation with functional decomposition</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the BayOTIDE</span>

<span class="sd">            References</span>
<span class="sd">            ----------</span>
<span class="sd">            https://arxiv.org/abs/2308.14906</span>
<span class="sd">            https://github.com/xuangu-fang/BayOTIDE</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ bayotide.impute(params={&quot;K_trend&quot;:30, &quot;K_season&quot;:1, &quot;n_season&quot;:10, &quot;K_bias&quot;:0, &quot;time_scale&quot;:1, &quot;a0&quot;:1, &quot;b0&quot;:1, &quot;v&quot;:1, &quot;num_fold&quot;:1})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Integration of the .npy file generation with nfold, reproducing the notebook preprocessing.</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Reversal of the ImputeGAP original matrix to preserve the expected format/shape logic.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;bay_otide&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.BayOTIDE.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.BayOTIDE.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using the Multivariate Time Series Imputation by Deep Learning</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the BayOTIDE algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        K_trend : int, (optional) (default: 20)</span>
<span class="sd">                            Number of trend factors.</span>

<span class="sd">                        K_season : int, (optional) (default: 2)</span>
<span class="sd">                            Number of seasonal factors.</span>

<span class="sd">                        n_season : int, (optional) (default: 5)</span>
<span class="sd">                            Number of seasonal components per factor.</span>

<span class="sd">                        K_bias : int, (optional) (default: 1)</span>
<span class="sd">                            Number of bias factors.</span>

<span class="sd">                        time_scale : float, (optional) (default: 1)</span>
<span class="sd">                            Time scaling factor.</span>

<span class="sd">                        a0 : float, (optional) (default: 0.6)</span>
<span class="sd">                            Hyperparameter for prior distribution.</span>

<span class="sd">                        b0 : float, (optional) (default: 2.5)</span>
<span class="sd">                            Hyperparameter for prior distribution.</span>

<span class="sd">                        v : float, (optional) (default: 0.5)</span>
<span class="sd">                            Variance parameter.</span>

<span class="sd">                        num_fold: int, optional</span>
<span class="sd">                             Number of fold used for training (default is 1).</span>

<span class="sd">                        config : dict, (optional) (default: None)</span>
<span class="sd">                            Dictionary containing all configuration parameters, that will replace all other parameters (see documentation).</span>

<span class="sd">                        args : object, (optional) (default: None)</span>
<span class="sd">                            Arguments containing all configuration parameters, that will replace all other parameters (see documentation).</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : BayOTIDE</span>
<span class="sd">                    BayOTIDE object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; bay_otide_imputer = Imputation.DeepLearning.BayOTIDE(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; bay_otide_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; bay_otide_imputer.impute(user_def=True, params={&quot;K_trend&quot;:30, &quot;K_season&quot;:1, &quot;n_season&quot;:10, &quot;K_bias&quot;:0, &quot;time_scale&quot;:1, &quot;a0&quot;:1, &quot;b0&quot;:1, &quot;v&quot;:1, &quot;num_fold&quot;:1})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; bay_otide_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = bay_otide_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                S. Fang, Q. Wen, Y. Luo, S. Zhe, and L. Sun, &quot;BayOTIDE: Bayesian Online Multivariate Time Series Imputation with Functional Decomposition,&quot; CoRR, vol. abs/2308.14906, 2024. [Online]. Available: https://arxiv.org/abs/2308.14906.</span>
<span class="sd">                https://github.com/xuangu-fang/BayOTIDE</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.bayotide</span><span class="w"> </span><span class="kn">import</span> <span class="n">bay_otide</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_dl_split</span><span class="p">(</span><span class="n">split_ratio</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span>
                    <span class="k">return</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">K_trend</span><span class="p">,</span> <span class="n">K_season</span><span class="p">,</span> <span class="n">n_season</span><span class="p">,</span> <span class="n">K_bias</span><span class="p">,</span> <span class="n">time_scale</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">num_fold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">K_trend</span><span class="p">,</span> <span class="n">K_season</span><span class="p">,</span> <span class="n">n_season</span><span class="p">,</span> <span class="n">K_bias</span><span class="p">,</span> <span class="n">time_scale</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">num_fold</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">bay_otide</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">K_trend</span><span class="o">=</span><span class="n">K_trend</span><span class="p">,</span> <span class="n">K_season</span><span class="o">=</span><span class="n">K_season</span><span class="p">,</span> <span class="n">n_season</span><span class="o">=</span><span class="n">n_season</span><span class="p">,</span> <span class="n">K_bias</span><span class="o">=</span><span class="n">K_bias</span><span class="p">,</span> <span class="n">time_scale</span><span class="o">=</span><span class="n">time_scale</span><span class="p">,</span> <span class="n">a0</span><span class="o">=</span><span class="n">a0</span><span class="p">,</span> <span class="n">b0</span><span class="o">=</span><span class="n">b0</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">num_fold</span><span class="o">=</span><span class="n">num_fold</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>




<div class="viewcode-block" id="Imputation.DeepLearning.HKMF_T">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.HKMF_T">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">HKMF_T</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            HKMF-T class to impute missing values using Recover From Blackouts in Tagged Time Series With Hankel Matrix Factorization</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the HKMF-T</span>

<span class="sd">            Examples</span>
<span class="sd">            --------</span>
<span class="sd">            $ hkmft.impute(params={&quot;tags&quot;:[], &quot;seq_len&quot;:7, &quot;blackouts_begin&quot;:0, &quot;blackouts_end&quot;:0, &quot;epochs&quot;:10})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Updating the deprecated DTW library and function.</span>

<span class="sd">            - Adjustment of the blackout logic to work with missingness patterns, automatically placing the block at the end of the matrix to prevent overlapping when not defined by the user.</span>

<span class="sd">            - Iteration over all series with contaminated values and invocation of the model for each one, since the algorithm operates on a single series.</span>

<span class="sd">            - Computation of an artificial tags list based on seq_len when the tags list is not provided.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;hkmf_t&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.HKMF_T.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.HKMF_T.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using Recover From Blackouts in Tagged Time Series With Hankel Matrix Factorization</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the HKMF-T algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        tags : numpy.ndarray, optional</span>
<span class="sd">                            An array containing tags that provide additional structure or metadata about</span>
<span class="sd">                            the input data. If None, no tags are used (default is None).</span>

<span class="sd">                        data_names : list of str, optional</span>
<span class="sd">                            List of names corresponding to each row or column of the dataset for interpretability.</span>
<span class="sd">                            If None, names are not used (default is None).</span>

<span class="sd">                        epoch : int, optional</span>
<span class="sd">                            The maximum number of training epochs for the Hankel Matrix Factorization algorithm.</span>
<span class="sd">                            If convergence is reached earlier, the process stops (default is 10).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : HKMF-T</span>
<span class="sd">                    HKMF-T object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; hkmf_t_imputer = Imputation.DeepLearning.HKMF_T(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; hkmf_t_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; hkmf_t_imputer.impute(user_def=True, params={&quot;tags&quot;:[], &quot;seq_len&quot;:7, &quot;blackouts_begin&quot;:0, &quot;blackouts_end&quot;: 0,&quot;epochs&quot;:10})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; hkmf_t_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = hkmf_t_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                L. Wang, S. Wu, T. Wu, X. Tao and J. Lu, &quot;HKMF-T: Recover From Blackouts in Tagged Time Series With Hankel Matrix Factorization,&quot; in IEEE Transactions on Knowledge and Data Engineering, vol. 33, no. 11, pp. 3582-3593, 1 Nov. 2021, doi: 10.1109/TKDE.2020.2971190. keywords: {Time series analysis;Matrix decomposition;Market research;Meteorology;Sparse matrices;Indexes;Software;Tagged time series;missing value imputation;blackouts;hankel matrix factorization}</span>
<span class="sd">                https://github.com/wangliang-cs/hkmf-t?tab=readme-ov-file</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.hkmf_t</span><span class="w"> </span><span class="kn">import</span> <span class="n">hkmf_t</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tags</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">blackouts_begin</span><span class="p">,</span> <span class="n">blackouts_end</span><span class="p">,</span> <span class="n">epochs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tags</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">blackouts_begin</span><span class="p">,</span> <span class="n">blackouts_end</span><span class="p">,</span> <span class="n">epochs</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tags</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">blackouts_begin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">blackouts_begin</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">blackouts_end</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">blackouts_end</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">hkmf_t</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="n">tags</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">blackouts_begin</span><span class="o">=</span><span class="n">blackouts_begin</span><span class="p">,</span> <span class="n">blackouts_end</span><span class="o">=</span><span class="n">blackouts_end</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.BitGraph">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.BitGraph">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">BitGraph</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            BitGraph class to impute missing values using BIASED TEMPORAL CONVOLUTION GRAPH NETWORK FOR TIME SERIES FORECASTING WITH MISSING VALUES</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the BitGraph</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ bit_graph.impute(params={&quot;seq_len&quot;:-1, &quot;sliding_windows&quot;:1, &quot;kernel_size&quot;:25, &quot;kernel_set&quot;:[2,3,6,7], &quot;epochs&quot;:50, &quot;batch_size&quot;: -1, &quot;subgraph_size&quot;:5, &quot;num_workers&quot;:0})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Addition of a custom loader (sliding-window strategy) for univariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - Addition of a custom loader (sampling strategy) for multivariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Addition of a reconstruction module to rebuild the full original imputed matrix (sum and average the windows (windows strategy) | merge the dimensions across samples (samples strategy)).</span>

<span class="sd">            - Adaptation of the forecasting logic for imputation by limiting the horizon to 0 during X and Y generation.</span>

<span class="sd">            - Automatic computation of seq_len and batch_size when not set.</span>

<span class="sd">            - Reduction of the epochs parameter to 50 for performance reasons.</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;bit_graph&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.BitGraph.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.BitGraph.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using BIASED TEMPORAL CONVOLUTION GRAPH NETWORK FOR TIME SERIES FORECASTING WITH MISSING VALUES</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the BitGraph algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        seq_len : int, optional</span>
<span class="sd">                            Length of the input sequence for temporal modeling (default: 1).</span>

<span class="sd">                        sliding_windows: int, optional</span>
<span class="sd">                            Stride between consecutive training windows (default is 1). If set to 0, the window size is equal to seq_len.</span>
<span class="sd">                            Use values  1 for univariate datasets (window strategy) and 0 for multivariate datasets (sample strategy).</span>

<span class="sd">                        kernel_size : int, optional</span>
<span class="sd">                            Size of the kernel used during training (most be smaller the seq_len). Default is 2.</span>

<span class="sd">                        kernel_set : list, optional</span>
<span class="sd">                            Set of kernel sizes used in the model for graph convolution operations (default: [1]).</span>

<span class="sd">                        epochs : int, optional</span>
<span class="sd">                            Number of training epochs (default: 10).</span>

<span class="sd">                        batch_size : int, optional</span>
<span class="sd">                            Size of each batch (default: 32).</span>

<span class="sd">                        subgraph_size : int, optional</span>
<span class="sd">                            The size of each subgraph used in message passing within the graph network (default: 5).</span>

<span class="sd">                        num_workers: int, optional</span>
<span class="sd">                             Number of worker for multiprocess (default is 0).</span>

<span class="sd">                        tr_ratio: float, optional</span>
<span class="sd">                            Split ratio between training and testing sets (default is 0.9).</span>

<span class="sd">                        seed : int, optional</span>
<span class="sd">                            Random seed for reproducibility (default: 42).</span>

<span class="sd">                        logs : bool, optional</span>
<span class="sd">                            Whether to log the execution time (default is True).</span>

<span class="sd">                        verbose : bool, optional</span>
<span class="sd">                            Whether to display the contamination information (default is True).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : BitGraph</span>
<span class="sd">                    BitGraph object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; bit_graph_imputer = Imputation.DeepLearning.BitGraph(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; bit_graph_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; bit_graph_imputer.impute(user_def=True, params={&quot;seq_len&quot;:-1, &quot;sliding_windows&quot;:1, &quot;kernel_size&quot;:25, &quot;kernel_set&quot;:[2,3,6,7], &quot;epochs&quot;:50, &quot;batch_size&quot;: -1, &quot;subgraph_size&quot;:5, &quot;num_workers&quot;:0})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; bit_graph_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = bit_graph_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                X. Chen1, X. Li, T. Wu, B. Liu and Z. Li, BIASED TEMPORAL CONVOLUTION GRAPH NETWORK FOR TIME SERIES FORECASTING WITH MISSING VALUES</span>
<span class="sd">                https://github.com/chenxiaodanhit/BiTGraph</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.bit_graph</span><span class="w"> </span><span class="kn">import</span> <span class="n">bit_graph</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">kernel_set</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">subgraph_size</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">kernel_set</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">subgraph_size</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>


                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">bit_graph</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="o">=</span><span class="n">sliding_windows</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span> <span class="n">kernel_set</span><span class="o">=</span><span class="n">kernel_set</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">subgraph_size</span><span class="o">=</span><span class="n">subgraph_size</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.SAITS">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.SAITS">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">SAITS</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SAITS class to impute missing values using Self-Attention-based Imputation for Time Series</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the SAITS</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">                $   imputer.impute(params={&quot;seq_len&quot;:24, &quot;batch_size&quot;:128, &quot;epochs&quot;:10000, &quot;sliding_windows&quot;:1, &quot;n_head&quot;:8, &quot;num_workers&quot;:0})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Addition of a custom loader (sliding-window strategy) for univariate data from ImputeGAP, including custom train/val/test splitting (based on the Electricity loader).</span>

<span class="sd">            - Addition of a custom loader (sampling strategy) for multivariate data from ImputeGAP, including custom train/val/test splitting (based on the PhysioNet loader).</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Addition of a reconstruction module to rebuild the full original imputed matrix (sum and average the windows (windows strategy) | merge the dimensions across samples (samples strategy)).</span>

<span class="sd">            - Computation of seq_len and batch_size based on the dataset shape.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;saits&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.SAITS.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.SAITS.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using Self-Attention-based Imputation for Time Series</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the SAITS algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        seq_len : int, optional</span>
<span class="sd">                                Length of the input sequence for temporal modeling (default: 1).</span>

<span class="sd">                        batch_size : int, optional, default=32</span>
<span class="sd">                            The number of samples per training batch.</span>

<span class="sd">                        epochs : int, optional</span>
<span class="sd">                            Number of training epochs (default: 10).</span>

<span class="sd">                        sliding_windows: int, optional</span>
<span class="sd">                            Stride between consecutive training windows (default is 1). If set to 0, the window size is equal to seq_len.</span>
<span class="sd">                            Use values  1 for univariate datasets (window strategy) and 0 for multivariate datasets (sample strategy).</span>

<span class="sd">                        n_head : int, optional</span>
<span class="sd">                            head num of self-attention (default: 4)</span>

<span class="sd">                        num_workers: int, optional</span>
<span class="sd">                            Number of worker for multiprocess (default is 0).</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : SAITS</span>
<span class="sd">                    SAITS object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; saits_imputer = Imputation.DeepLearning.BitGraph(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; saits_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; saits_imputer.impute(user_def=True, params={&quot;seq_len&quot;:24, &quot;batch_size&quot;:128, &quot;epochs&quot;:10000, &quot;sliding_windows&quot;:1, &quot;n_head&quot;:8, &quot;num_workers&quot;:0})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; saits_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = saits_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Wenjie Du, David Cot, Yan Liu. SAITS: Self-attention-based imputation for time series. arXiv, 2023</span>
<span class="sd">                https://github.com/WenjieDu/SAITS</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.saits</span><span class="w"> </span><span class="kn">import</span> <span class="n">saits</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">n_head</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">n_head</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">saits</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="o">=</span><span class="n">sliding_windows</span><span class="p">,</span> <span class="n">n_head</span><span class="o">=</span><span class="n">n_head</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.TimesNet">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.TimesNet">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">TimesNet</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            TimesNet class to impute missing values (Model used from the TimesNet repository)</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the TimesNet</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ timesnet.impute(params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;: 10, &quot;gpt_layers&quot;:3, &quot;num_workers&quot;:0, &quot;seed&quot;:2021})</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Addition of a custom loader (sliding-window strategy) for univariate data from ImputeGAP, including custom train/val/test splitting (based on CUSTOMs loader).</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Automatic computation of dataset timestamps (datetime meta-information) if not provided.</span>

<span class="sd">            - Addition of a mask in __getitem__ to correctly map and mask the ImputeGAP contamination during training and testing.</span>

<span class="sd">            - Adaptation of the forecasting logic for imputation by limiting the horizon to 0.</span>

<span class="sd">            - Reduction of the number of epochs to 10 for performance reasons.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;timesnet&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.TimesNet.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.TimesNet.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using TimesNet</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the timesnet algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        seq_len : int, optional</span>
<span class="sd">                            Length of the input sequence for the encoder. If -1, it will be automatically determined (default: -1).</span>

<span class="sd">                        batch_size : int, optional</span>
<span class="sd">                            Number of samples per batch during training/inference. If -1, it will be auto-set (default: -1).</span>

<span class="sd">                        epochs : int, optional</span>
<span class="sd">                            Number of epoch for training the model (default: 10).</span>

<span class="sd">                        gpt_layers : int, optional</span>
<span class="sd">                            Number of layers in the transformer/generator component (default: 6).</span>

<span class="sd">                        num_workers: int, optional</span>
<span class="sd">                             Number of worker for multiprocess (default is 0).</span>

<span class="sd">                        seed : int, optional</span>
<span class="sd">                            Random seed for reproducibility (default: 2021).</span>



<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : TimesNet</span>
<span class="sd">                    TimesNet object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; timesnet_imputer = Imputation.LLMs.GPT4TS(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; timesnet_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; timesnet_imputer.impute(user_def=True, params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;: 10, &quot;gpt_layers&quot;:3, &quot;num_workers&quot;:0, &quot;seed&quot;:2021})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; timesnet_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = timesnet_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                haixu wu  Tengge Hu  Yong Liu  Hang Zhou  Jianmin Wang  Mingsheng Long : &quot;TimesNet: Temporal 2D-Variation Modeling for General Time Series Analysis&quot;, ICLR 2023</span>
<span class="sd">                https://github.com/thuml/Time-Series-Library/tree/main</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.timesnet</span><span class="w"> </span><span class="kn">import</span> <span class="n">timesnet</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">gpt_layers</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">gpt_layers</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">timesnet</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">gpt_layers</span><span class="o">=</span><span class="n">gpt_layers</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>


<div class="viewcode-block" id="Imputation.DeepLearning.CSDI">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.CSDI">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">CSDI</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            CSDI class to impute missing values (Model used from the CSDI repository)</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the CSDI</span>


<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">            $ imputer.impute(params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;: 50, &quot;sliding_windows&quot;:1, &quot;target_strategy&quot;:&quot;random&quot;, &quot;nsamples&quot;: 1, &quot;num_workers&quot;:0})</span>


<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Addition of a custom loader (sliding-window strategy) for univariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - Addition of a custom loader (sampling strategy) for multivariate data from ImputeGAP, including custom train/val/test splitting.</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Addition of a reconstruction module to rebuild the full original imputed matrix (sum and average the windows (windows strategy) | merge the dimensions across samples (samples strategy)).</span>

<span class="sd">            - Computation of seq_len and batch_size based on the dataset shape.</span>

<span class="sd">            - Reduction of the epochs parameter to 50 and the nsamples parameter to 1 for performance reasons.</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;csdi&quot;</span>

<div class="viewcode-block" id="Imputation.DeepLearning.CSDI.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.DeepLearning.CSDI.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using CSDI</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the CSDI algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        seq_len : int, optional</span>
<span class="sd">                            Length of the input sequence for the encoder. If -1, it will be automatically determined (default: -1).</span>

<span class="sd">                        batch_size : int, optional</span>
<span class="sd">                            Number of samples per batch during training/inference. If -1, it will be auto-set (default: -1).</span>

<span class="sd">                        epochs : int, optional</span>
<span class="sd">                            Number of epoch for training the model (default: 10).</span>

<span class="sd">                        sliding_windows: int, optional</span>
<span class="sd">                            Stride between consecutive training windows (default is 1). If set to 0, the window size is equal to seq_len.</span>
<span class="sd">                            Use values  1 for univariate datasets (window strategy) and 0 for multivariate datasets (sample strategy).</span>

<span class="sd">                        target_strategy: str, optional</span>
<span class="sd">                            The strategy to use for targeting missing values pattern. Options include: &quot;mix&quot;, &quot;block&quot;, &quot;random&quot; (default is &quot;mix&quot;).</span>

<span class="sd">                        nsamples: int, optional</span>
<span class="sd">                            Number of trajectories generated by the diffusion process (default: 1).</span>

<span class="sd">                        num_workers: int, optional</span>
<span class="sd">                             Number of worker for multiprocess (default is 0).</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : CSDI</span>
<span class="sd">                    CSDI object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; csdi_imputer = Imputation.DeepLearning.CSDI(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; csdi_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; csdi_imputer.impute(user_def=True, params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;: 50, &quot;sliding_windows&quot;:1, &quot;target_strategy&quot;:&quot;random&quot;, &quot;nsamples&quot;: 1, &quot;num_workers&quot;:0})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; csdi_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = csdi_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Yusuke Tashiro  Jiaming Song  Yang Song  Stefano Ermon : &quot;CSDI: Conditional Score-based Diffusion Models for Probabilistic Time Series Imputation&quot;, NeurIPS&#39;21</span>
<span class="sd">                https://github.com/ermongroup/CSDI</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.csdi</span><span class="w"> </span><span class="kn">import</span> <span class="n">csdi</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">target_strategy</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="p">,</span> <span class="n">target_strategy</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">csdi</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">sliding_windows</span><span class="o">=</span><span class="n">sliding_windows</span><span class="p">,</span> <span class="n">target_strategy</span><span class="o">=</span><span class="n">target_strategy</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>
</div>





<div class="viewcode-block" id="Imputation.LLMs">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.LLMs">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">LLMs</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class containing specific imputation algorithms for Pre-trained Language Models (LLMs)</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Imputation.LLMs.NuwaTS">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.LLMs.NuwaTS">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">NuwaTS</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            NuwaTS class to impute missing values using Foundation Model Mending Every Incomplete Time Series</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the NuwaTS</span>

<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">                &gt;&gt;&gt; nuwats_imputer.impute(user_def=True, params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;:10, &quot;gpt_layers&quot;:6, &quot;num_workers&quot;:0, &quot;seed&quot;:2021})  # user defined&gt; or</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;nuwats&quot;</span>

<div class="viewcode-block" id="Imputation.LLMs.NuwaTS.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.LLMs.NuwaTS.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using Foundation Model Mending Every Incomplete Time Series</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the nuwats algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        seq_len : int, optional</span>
<span class="sd">                            Length of the input sequence for the encoder. If -1, it will be automatically determined (default: -1).</span>

<span class="sd">                        batch_size : int, optional</span>
<span class="sd">                            Number of samples per batch during training/inference. If -1, it will be auto-set (default: -1).</span>

<span class="sd">                        epochs : int, optional</span>
<span class="sd">                            Number of epoch for training the model (default: 10).</span>

<span class="sd">                        gpt_layers : int, optional</span>
<span class="sd">                            Number of layers in the transformer/generator component (default: 6).</span>

<span class="sd">                        num_workers: int, optional</span>
<span class="sd">                             Number of worker for multiprocess (default is 0).</span>

<span class="sd">                        seed : int, optional</span>
<span class="sd">                            Random seed for reproducibility (default: 2021).</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : NuwaTS</span>
<span class="sd">                    NuwaTS object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; nuwats_imputer = Imputation.LLMs.NuwaTS(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; nuwats_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; nuwats_imputer.impute(user_def=True, params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;: 10, &quot;gpt_layers&quot;:6, &quot;num_workers&quot;:0, &quot;seed&quot;:2021})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; nuwats_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = nuwats_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Cheng, Jinguo and Yang, Chunwei and Cai, Wanlin and Liang, Yuxuan and Wen, Qingsong and Wu, Yuankai: &quot;NuwaTS: Mending Every Incomplete Time Series&quot;, arXiv&#39;2024</span>
<span class="sd">                https://github.com/Chengyui/NuwaTS/tree/master</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.nuwats</span><span class="w"> </span><span class="kn">import</span> <span class="n">nuwats</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">gpt_layers</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">gpt_layers</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">nuwats</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">gpt_layers</span><span class="o">=</span><span class="n">gpt_layers</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="Imputation.LLMs.GPT4TS">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.LLMs.GPT4TS">[docs]</a>
        <span class="k">class</span><span class="w"> </span><span class="nc">GPT4TS</span><span class="p">(</span><span class="n">BaseImputer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            GPT4TS class to impute missing values using Foundation Model Mending Every Incomplete Time Series</span>
<span class="sd">            (Model used from the NuwaTS repository)</span>

<span class="sd">            Methods</span>
<span class="sd">            -------</span>
<span class="sd">            impute(self, user_def=True, params=None):</span>
<span class="sd">                Perform imputation using the GPT4TS</span>


<span class="sd">            Example</span>
<span class="sd">            -------</span>
<span class="sd">                &gt;&gt;&gt; gpt4ts_imputer.impute(user_def=True, params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;: 10, &quot;gpt_layers&quot;:3, &quot;num_workers&quot;:0, &quot;seed&quot;:2021})  # user defined&gt; or</span>

<span class="sd">            Changes</span>
<span class="sd">            -------</span>
<span class="sd">            - Addition of a custom loader (sliding-window strategy) for univariate data from ImputeGAP, including custom train/val/test splitting (based on CUSTOMs loader).</span>

<span class="sd">            - The missing values used for testing are added on top of the masks introduced by authors.</span>

<span class="sd">            - Automatic computation of timestamps (datetime meta-information) for plane dataset.</span>

<span class="sd">            - Addition of a mask in __getitem__ to correctly map and mask the ImputeGAP contamination during training and testing.</span>

<span class="sd">            - Adaptation of the forecasting logic for imputation by limiting the horizon to 0.</span>

<span class="sd">            - Computation of seq_len and batch_size based on the dataset shape.</span>

<span class="sd">            - Reduction of the number of epochs to 10 for performance reasons</span>


<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">algorithm</span> <span class="o">=</span> <span class="s2">&quot;gpt4ts&quot;</span>

<div class="viewcode-block" id="Imputation.LLMs.GPT4TS.impute">
<a class="viewcode-back" href="../../../imputegap.imputation.html#imputegap.recovery.imputation.Imputation.LLMs.GPT4TS.impute">[docs]</a>
            <span class="k">def</span><span class="w"> </span><span class="nf">impute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_def</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform imputation using GPT4TS (Foundation Model Mending Every Incomplete Time Series)</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                user_def : bool, optional</span>
<span class="sd">                    Whether to use user-defined or default parameters (default is True).</span>

<span class="sd">                params : dict, optional</span>
<span class="sd">                    Parameters of the gpt4ts algorithm or Auto-ML configuration, if None, default ones are loaded.</span>

<span class="sd">                tr_ratio: float, optional</span>
<span class="sd">                    Split ratio between training and testing sets (default is 0.9).</span>


<span class="sd">                    **Algorithm parameters:**</span>

<span class="sd">                        seq_len : int, optional</span>
<span class="sd">                            Length of the input sequence for the encoder. If -1, it will be automatically determined (default: -1).</span>

<span class="sd">                        batch_size : int, optional</span>
<span class="sd">                            Number of samples per batch during training/inference. If -1, it will be auto-set (default: -1).</span>

<span class="sd">                        epochs : int, optional</span>
<span class="sd">                            Number of epoch for training the model (default: 10).</span>

<span class="sd">                        gpt_layers : int, optional</span>
<span class="sd">                            Number of layers in the transformer/generator component (default: 6).</span>

<span class="sd">                        num_workers: int, optional</span>
<span class="sd">                             Number of worker for multiprocess (default is 0).</span>

<span class="sd">                        seed : int, optional</span>
<span class="sd">                            Random seed for reproducibility (default: 2021).</span>


<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                self : GPT4TS</span>
<span class="sd">                    GPT4TS object with `recov_data` set.</span>

<span class="sd">                Example</span>
<span class="sd">                -------</span>
<span class="sd">                    &gt;&gt;&gt; gpt4ts_imputer = Imputation.LLMs.GPT4TS(incomp_data)</span>
<span class="sd">                    &gt;&gt;&gt; gpt4ts_imputer.impute()  # default parameters for imputation &gt; or</span>
<span class="sd">                    &gt;&gt;&gt; gpt4ts_imputer.impute(user_def=True, params={&quot;seq_len&quot;:-1, &quot;batch_size&quot;:-1, &quot;epochs&quot;: 10, &quot;gpt_layers&quot;:3, &quot;num_workers&quot;:0, &quot;seed&quot;:2021})  # user defined&gt; or</span>
<span class="sd">                    &gt;&gt;&gt; gpt4ts_imputer.impute(user_def=False, params={&quot;input_data&quot;: ts.data, &quot;optimizer&quot;: &quot;ray_tune&quot;})  # auto-ml with ray_tune</span>
<span class="sd">                    &gt;&gt;&gt; recov_data = gpt4ts_imputer.recov_data</span>

<span class="sd">                References</span>
<span class="sd">                ----------</span>
<span class="sd">                Cheng, Jinguo and Yang, Chunwei and Cai, Wanlin and Liang, Yuxuan and Wen, Qingsong and Wu, Yuankai: &quot;NuwaTS: Mending Every Incomplete Time Series&quot;, arXiv&#39;2024</span>
<span class="sd">                https://github.com/Chengyui/NuwaTS/tree/master</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="kn">from</span><span class="w"> </span><span class="nn">imputegap.algorithms.gpt4ts</span><span class="w"> </span><span class="kn">import</span> <span class="n">gpt4ts</span>

                <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">gpt_layers</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_params</span><span class="p">(</span><span class="n">user_def</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">gpt_layers</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">recov_data</span> <span class="o">=</span> <span class="n">gpt4ts</span><span class="p">(</span><span class="n">incomp_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">incomp_data</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="n">seq_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span> <span class="n">gpt_layers</span><span class="o">=</span><span class="n">gpt_layers</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">tr_ratio</span><span class="o">=</span><span class="n">tr_ratio</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">logs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span></div>
</div>
</div>
</div>


</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Quentin Nater
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=58fbf978"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    </body>
</html>